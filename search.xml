<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Java关键字总结</title>
      <link href="2021/0623java-guan-jian-zi-zong-jie.html"/>
      <url>2021/0623java-guan-jian-zi-zong-jie.html</url>
      
        <content type="html"><![CDATA[<h1 id="Java-关键字总结"><a href="#Java-关键字总结" class="headerlink" title="Java 关键字总结"></a>Java 关键字总结</h1><blockquote><p>参考自 Guide哥 <a href="https://github.com/Snailclimb/JavaGuide">JavaGuide</a></p><p>基本是照着手敲了一遍（加深点印象QAQ</p></blockquote><h2 id="final"><a href="#final" class="headerlink" title="final"></a>final</h2><p><strong>final，意思是最终的，也就是不可改变的，用来修饰类、方法和变量，注意以下特点：</strong></p><ol><li><strong>final修饰的类不能被继承</strong>，final类中所有的成员方法都会隐式地指定为final；</li><li><strong>final修饰的方法不能被重写</strong>；</li><li>final修饰的变量为<strong>常量</strong>，如果是基本数据类型，则其值在初始化之后便不能更改；如果是引用类型，则在其初始化之后便不能让其指向另一个对象。</li></ol><p><strong>为什么用final</strong></p><ol><li><strong>锁定方法</strong>，防止任何继承类修改它的含义</li><li><strong>效率</strong>，早期的Java实现版本会将final方法转为内嵌调用。但方法过于庞大则看不到性能提升（现在的Java版本不需要使用final方法进行这些优化了）。类中所有的private方法都隐式地指定为final。</li></ol><h2 id="static"><a href="#static" class="headerlink" title="static"></a>static</h2><p><strong>使用场景：</strong></p><ol><li><p><strong>修饰成员变量和成员方法</strong>：被 static 修饰的成员属于类，不属于单个这个类的某个对象，被类中的所有对象共享，可以并且建议通过类名调用。被 static 声明的成员变量属于静态成员变量，静态变量存放在 Java 内存区域的方法区。</p><p>调用格式：<code>类名.静态变量名</code></p></li><li></li></ol>]]></content>
      
      
      <categories>
          
          <category> Summary </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关系数据库理论</title>
      <link href="2021/0522-guan-xi-shu-ju-ku-li-lun.html"/>
      <url>2021/0522-guan-xi-shu-ju-ku-li-lun.html</url>
      
        <content type="html"><![CDATA[<h1 id="关系数据库规范化理论"><a href="#关系数据库规范化理论" class="headerlink" title="关系数据库规范化理论"></a>关系数据库规范化理论</h1><blockquote><p>如何使用关系模型设计关系数据库？也就是面对一个现实问题，如何选择一个比较好的关系模式的集合，每个关系又应该由哪些属性组成？这属于数据库设计的问题，确切地讲是数据库逻辑设计的问题。</p></blockquote><h2 id="规范化问题的提出"><a href="#规范化问题的提出" class="headerlink" title="规范化问题的提出"></a>规范化问题的提出</h2><ul><li>在关系数据库系统中，关系模型包括一组<strong>关系模式</strong>，各个关系不是完全孤立的，数据库的设计较层次和网状模型更为重要。</li><li>如何设计一个适合的关系数据库系统，关键是关系数据库模式的设计，一个好的关系数据库模式应该包括多少关系模式，而每一个关系模式又应该包括哪些属性，又如何将这些相互关联的关系模式组建一个适合的关系模型，这些工作决定了整个系统运行的效率，也是系统成败的关键所在，所以必须在关系数据库的<strong>规范化理论</strong>的指导下逐步完成。 </li></ul><p>关系数据库的规范化理论主要包括三个方面的内容：</p><ul><li>函数依赖</li><li>范式（Normal Form）</li><li>模式设计</li></ul><p>其中，函数信赖起着核心的作用，是模式分解和模式设计的基础，范式是模式分解的标准。</p><p>一个<strong>好的关系模式</strong>应该具备以下四个条件：</p><ul><li>尽可能少的数据冗余</li><li>没有插入异常</li><li>没有删除异常</li><li>没有更新异常</li></ul><p>如何按照一定的规范设计关系模式，将结构复杂的关系分解成结构简单的关系，从而把不好的关系数据库模式转变为好的关系数据库模式，这就是<strong>关系的规范化</strong>。</p><p>规范化又可以根据不同的要求而分成若干级别。</p><p>我们要设计的关系模式中的各属性是相互依赖、相互制约的，这样才构成了一个结构严谨的整体。</p><p>因此在设计关模式时，必须从语义上分析这些<strong>依赖关系</strong>。</p><p>数据库模式的好坏和关系中各属性间的依赖关系有关，因此，我们先讨论属性间的依赖关系，然后再讨论关系规范化理论。 </p><h2 id="函数依赖"><a href="#函数依赖" class="headerlink" title="函数依赖"></a>函数依赖</h2><h3 id="函数依赖的定义和性质"><a href="#函数依赖的定义和性质" class="headerlink" title="函数依赖的定义和性质"></a>函数依赖的定义和性质</h3><ul><li>关系模式中的各属性之间相互依赖、相互制约的联系称为<u>数据依赖</u>。</li><li>数据依赖一般分为<u>函数依赖、多值依赖和连接依赖</u>。</li><li>其中，<strong>函数依赖</strong>是最重要的数据依赖。</li></ul><p>函数依赖（Functional Dependency）是关系模式中属性之间的一种<strong>逻辑依赖关系</strong>。</p><blockquote><p>例如在上一节介绍的关系模式SCD中，SNO与SN、AGE、DEPT之间都有一种依赖关系。</p><p>由于一个SNO只对应一个学生，而一个学生只能属于一个系，所以当SNO的值确定之后，SN，AGE，DEPT的值也随之被唯一的确定了。</p><p>这类似于变量之间的单值函数关系。设单值函数Y=F(X)，自变量X的值可以决定一个唯一的函数值Y。</p><p>在这里，我们说SNO决定函数（SN，AGE，DEPT），或者说（SN，AGE，DEPT）函数依赖于SNO。</p></blockquote><h4 id="形式化定义"><a href="#形式化定义" class="headerlink" title="形式化定义"></a>形式化定义</h4><p>设关系模式R(U，F)，U是属性全集，F是U上的函数依赖集，X和Y是U的子集，如果对于R(U)的任意一个可能的关系r，<u>对于X的每一个具体值，Y都有唯一的具体值与之对应</u>，则称X决定函数Y，或Y函数依赖于X，记作X→Y。我们称X为决定因素，Y为依赖因素。</p><p><strong>几点说明：</strong></p><ol><li>平凡的函数依赖与非平凡的函数依赖。<ul><li>当属性集Y是属性集X的子集时，则必然存在着函数依赖X→Y,这种类型的函数依赖称为平凡的函数依赖。 （SNO，CNO）→SNO</li><li>如果Y不是X的子集，则称X→Y为非平凡的函数依赖。</li><li>若不特别声明，我们讨论的都是<u>非平凡的函数依赖</u>。</li></ul></li><li>函数依赖是语义范畴的概念。<ul><li>我们只能<strong>根据语义来确定</strong>一个函数依赖，而<strong>不能按照其形式化定义来证明</strong>一个函数依赖是否成立。</li><li>例如，对于关系模式S，当学生不存在重名的情况下，可以得到： SN→AGE SN→DEPT</li><li>这种函数依赖关系，必须是在没有重名的学生条件下才成立的，否则就不存在函数依赖了。所以函数依赖反映了一种语义完整性约束。</li></ul></li><li>函数依赖关系的存在与时间无关。<ul><li>因为函数依赖是指关系中的所有元组应该满足的约束条件，而不是指关系中某个或某些元组所满足的约束条件。</li><li>当关系中的元组增加、删除或更新后都不能破坏这种函数依赖。</li><li>因此，必须根据语义来确定属性之间的函数依赖，而<strong>不能单凭某一时刻关系中的实际数据值来判断</strong>。</li><li>例如，对于关系模式S，假设没有给出无重名的学生这种语义规定，则即使当前关系中没有重名的记录，也只能存在函数依赖SNO→SN，而不能存在函数依赖SN→SNO，因为如果新增加一个重名的学生，函数依赖SN→SNO必然不成立。</li><li>所以函数依赖关系的存在与时间无关，而只与数据之间的语义规定有关。 </li></ul></li><li>函数依赖可以保证关系分解的无损连接性。<ul><li>设R（X，Y，Z），X，Y，Z为不相交的属性集合，如果X→Y或X→Z，则有R(X，Y，Z) = R[X，Y] * R[X，Z]</li><li>其中，R[X，Y]表示关系R在属性（X，Y）上的投影，即R等于其投影在X上的自然连接，这样便保证了关系R分解后不会丢失原有的信息，称作<strong>关系分解的无损连接性</strong>。</li><li>例如，对于关系模式SCD，有SNO→（SN，AGE，DEPT，MN），SCD（SNO，SN，AGE，DEPT，MN，CNO，SCORE）=SCD[SNO，SN，AGE，DEPT，MN]*SCD[SNO，CNO，SCORE]，也就是说，用其投影在SNO上的自然连接可复原关系模式SCD。</li><li>这一性质非常重要，在后一节的关系规范化中要用到。 </li></ul></li></ol><h4 id="基本性质"><a href="#基本性质" class="headerlink" title="基本性质"></a>基本性质</h4><ol><li><p>投影性</p><ul><li>根据平凡的函数依赖的定义可知，一组属性函数决定它的所有子集。</li><li>例如，在关系SCD中，（SNO，CNO）→SNO和（SNO，CNO）→CNO。</li></ul></li><li><p>扩张性</p><ul><li>若X→Y且W→Z，则（X，W）→（Y，Z）。</li><li>例如，SNO→（SN，AGE），DEPT→MN，则有（SNO，DEPT）→（SN，AGE，MN）。</li></ul></li><li><p>合并性</p><ul><li>若X→Y且X→Z则必有X→（Y，Z）。</li><li>例如，在关系SCD中，SNO→（SN，AGE），SNO→（DEPT，MN），则有SNO→（SN，AGE，DEPT，MN）。</li></ul></li><li><p>分解性</p><p>若X→（Y，Z）,则X→Y且X→Z。很显然，<strong>分解性为合并性的逆过程</strong>。</p></li></ol><p>由合并性和分解性，很容易得到以下事实：</p><p>X→A1，A2，…，An成立的充分必要条件是X→Ai（i=1,2,…,n）成立。</p><h3 id="完全函数依赖与部分函数依赖"><a href="#完全函数依赖与部分函数依赖" class="headerlink" title="完全函数依赖与部分函数依赖"></a>完全函数依赖与部分函数依赖</h3><p>设关系模式R(U)，U是属性全集，X和Y是U的子集，</p><ul><li>如果X→Y，并且对于X的任何一个真子集X′，都有X′不→Y，则称Y对X完全函数依赖（Full Functional Dependency）。</li><li>如果对X的某个真子集X′，有X′→Y，则称Y对部分函数依赖（Partial Functional Dependency）。</li></ul><p>由上述定义可知：</p><ul><li>只有当决定因素是组合属性时，讨论部分函数依赖才有意义，</li><li>当决定因素是单属性时，只能是完全函数依赖。</li><li>例如，在关系模式S（SNO，SN，AGE，DEPT），决定因素为单属性SNO，有SNO→（SN，AGE，DEPT），不存在部分函数依赖。</li></ul><h3 id="传递函数依赖"><a href="#传递函数依赖" class="headerlink" title="传递函数依赖"></a>传递函数依赖</h3><p>设有关系模式R（U），U是属性全集，X，Y，Z是U的子集，</p><ul><li>若X→Y，Y→Z，这时如果Y→X，称Z对X直接函数依赖，而不是传递函数依赖。否则称Z对X传递函数依赖（Transitive Functional Dependency）。</li></ul><p>综上所述，函数依赖分为<u>完全函数依赖、部分函数依赖和传递函数依赖</u>三类，它们是规范化理论的依据和规范化程度的准则，下面我们将以介绍的这些概念为基础，进行数据库的规范设计。 </p><hr><h2 id="范式"><a href="#范式" class="headerlink" title="范式"></a>范式</h2><blockquote><p>规范化的基本思想是消除关系模式中的数据冗余，消除数据依赖中的不合适的部分，解决数据插入、删除时发生异常现象。这就要求关系数据库设计出来的关系模式要满足一定的条件。</p><p>我们把关系数据库的规范化过程中为不同程度的规范化要求设立的不同标准称为范式（Normal Form）。由于规范化的程度不同，就产生了不同的范式。</p><p>满足最基本规范化要求的关系模式叫第一范式（1NF），在第一范式中进一步满足一些要求为第二范式（3NF），以此类推就产生了第三范式（3NF）等概念。</p><p>每种范式都规定了一些限制约束条件。 </p></blockquote><h3 id="第一范式"><a href="#第一范式" class="headerlink" title="第一范式"></a>第一范式</h3><p>第一范式（First Normal Form）是最基本的规范形式，即关系中每个属性都是==不可再分==的简单项。</p><p><strong>定义：</strong>如果关系模式R，其所有的属性均为简单属性，即每个属性域都是不可再分的，则称R属于第一范式，简称1NF，记作R∈1NF。</p><ul><li>在讨论关系的性质时，我们把满足这个条件的关系称为规范化关系。</li><li>在关系数据库系统中只讨论规范化的关系，凡是非规范化的关系模式必须化成规范化的关系。</li><li>在非规范化的关系中去掉组合项就能化成规范化的关系。</li><li>每个规范化的关系都属于1NF，这也是它之所以称为“第一”的原因。</li></ul><h3 id="第二范式"><a href="#第二范式" class="headerlink" title="第二范式"></a>第二范式</h3><p><strong>定义：</strong>如果关系模式R∈1NF，且每个非主属性都==完全函数依赖于==R的每个关系键，则称R属于第二范式（Second Normal Form），简称2NF，记作R∈2NF。</p><p>在关系模式SCD中，SNO，CNO为主属性，AGE，DEPT，MN，SCORE均为非主属性，经上述分析，存在非主属性对关系键的部分函数依赖，所以SCD不是2NF。</p><blockquote><p>关系键的定义</p><p>设关系模式R的属性集是U，X是U的一个子集。如果X→U在R上成立，那么称X是R的一个超键。如果X→U在R上成立，但对于X的任一真子集X1都有X1→U不成立，那么称X是R上的一个候选键。可任意指定一个候选键为主键。在任一候选键中出现过的属性成为主属性。</p></blockquote><ol><li>从1NF关系中<strong>消除非主属性对关系键的部分函数依赖</strong>，则可得到2NF关系。</li><li>如果R的<strong>关系键为单属性</strong>，或R的<strong>全体属性均为主属性</strong>，则R∈2NF。</li></ol><h4 id="2NF规范化"><a href="#2NF规范化" class="headerlink" title="2NF规范化"></a><strong>2NF规范化</strong></h4><p>2NF规范化是指把1NF关系模式通过<u>投影分解</u>转换成2NF关系模式的集合。</p><p>分解时遵循的基本原则就是“一事一表”，让一个关系只描述一个实体或者实体间的联系。如果多于一个实体或联系，则进行投影分解。</p><h4 id="2NF的缺点"><a href="#2NF的缺点" class="headerlink" title="2NF的缺点"></a><strong>2NF的缺点</strong></h4><p>2NF的关系模式解决了1NF中存在的一些问题，2NF规范化的程度比1NF前进了一步，但2NF的关系模式在进行数据操作时，仍然存在着一些问题。这是由于在SCD中存在着非主属性对主键的传递依赖。为此，对关系模式SCD还需进一步简化，<strong>消除这种传递依赖</strong>，得到3NF。</p><h3 id="第三范式"><a href="#第三范式" class="headerlink" title="第三范式"></a>第三范式</h3><p><strong>定义：</strong>如果关系模式R∈2NF，且每个非主属性都==不传递依赖==于R的每个关系键，则称R属于第三范式（Third Normal Form），简称3NF，记作R∈3NF。</p><ol><li>如果R∈3NF，则R也是2NF。</li><li>如果R∈2NF，则R不一定是3NF。</li></ol><h4 id="3NF规范化"><a href="#3NF规范化" class="headerlink" title="3NF规范化"></a><strong>3NF规范化</strong></h4><p>3NF规范化是指把2NF关系模式通过<u>投影分解</u>转换成3NF关系模式的集合。</p><p>n和2NF的规范化时遵循的原则相同，即“一事一表”，让一个关系只描述一个实体或者实体间的联系。</p><ul><li>但是，3NF只限制了非主属性对键的依赖关系，而没有限制主属性对键的依赖关系。</li><li>如果发生了这种依赖，仍有可能存在数据冗余、插入异常、删除异常和修改异常。</li><li>这时，则需对3NF进一步规范化，<strong>消除主属性对键的依赖关系</strong>，为了解决这种问题，Boyce与Codd共同提出了一个新范式的定义，这就是Boyce-Codd范式，通常简称BCNF或BC范式。它弥补了3NF的不足。</li></ul><hr><h3 id="BC范式"><a href="#BC范式" class="headerlink" title="BC范式"></a>BC范式</h3><p><strong>定义：</strong>如果关系模式R∈1NF，且所有的函数依赖X→Y（Y 不∈X），决定因素X都包含了R的一个候选键，则称R属于BC范式（Boyce-Codd Normal Form），记作R∈BCNF。</p><ol><li>满足BCNF的关系将消除任何属性（主属性或非主属性）对键的部分函数依赖和传递函数依赖。也就是说，如果R∈BCNF，则R也是3NF。</li><li>如果R∈3NF，则R不一定是BCNF。</li></ol><h4 id="BCNF规范化"><a href="#BCNF规范化" class="headerlink" title="BCNF规范化"></a><strong>BCNF规范化</strong></h4><p>BCNF规范化是指把3NF关系模式通过投影分解转换成BCNF关系模式的集合。</p><p>==下面以3NF关系模式SNC为例，来说明BCNF规范化的过程。==</p><p>例　将SNC(SNO，SN，CNO，SCORE)规范到BCNF。</p><ul><li>分析SNC数据冗余的原因，是因为在这一个关系中存在两个实体，一个为学生实体，属性有SNO、SN；另一个是选课实体，属性有SNO、CNO和SCORE。</li><li>根据分解的原则，我们可以将SNC分解成如下两个关系：<ul><li>S1(SNO，SN)，描述学生实体；</li><li>S2(SNO，CNO，SCORE)，描述学生与课程的联系。</li></ul></li><li>对于S1，有两个候选键SNO和SN，对于S2，主键为（SNO，CNO）。</li><li>在这两个关系中，无论主属性还是非主属性都不存在对键的部分依赖和传递依赖，S1∈BCNF，S2∈BCNF。</li></ul><hr><p>如果一个关系数据库中所有关系模式都属于3NF，则已在很大程度上消除了插入异常和删除异常，但由于可能存在主属性对候选键的部分依赖和传递依赖，因此关系模式的分离仍不够彻底。</p><p>如果一个关系数据库中所有关系模式都属于BCNF，那么在函数依赖的范畴内，已经实现了模式的彻底分解，消除了产生插入异常和删除异常的根源，而且数据冗余也减少到极小程度。 </p><h2 id="关系模式的规范化"><a href="#关系模式的规范化" class="headerlink" title="关系模式的规范化"></a>关系模式的规范化</h2><blockquote><p>到目前为止，规范化理论已经提出了六类范式（有关4NF和5NF的内容不再详细介绍）。</p><p>各范式级别是在分析函数依赖条件下对关系模式分离程度的一种测度，范式级别可以逐级升高。</p><p>一个低一级范式的关系模式，通过模式分解转化为若干个高一级范式的关系模式的集合，这种分解过程叫作关系模式的规范化（Normalization）。</p></blockquote><h3 id="关系模式规范化的目的和原则"><a href="#关系模式规范化的目的和原则" class="headerlink" title="关系模式规范化的目的和原则"></a>关系模式规范化的目的和原则</h3><p>一个关系只要其分量都是不可分的数据项，就可称作规范化的关系，但这只是最基本的规范化。这样的关系模式是合法的。但人们发现有些关系模式存在插入、删除、修改异常、数据冗余等弊病。</p><p><strong>规范化的目的就是使结构合理，消除存储异常，使数据冗余尽量小，便于插入、删除和更新</strong>。 </p><ul><li>规范化的基本原则就是遵从概念单一化“一事一表”的原则，即一个关系只描述一个实体或者实体间的联系。</li><li>若多于一个实体，就把它“分离”出来。</li><li>因此，所谓规范化，实质上是概念的单一化，即一个关系表示一个实体。</li></ul><h3 id="关系模式规范化的步骤"><a href="#关系模式规范化的步骤" class="headerlink" title="关系模式规范化的步骤"></a>关系模式规范化的步骤</h3><p>规范化就是对原关系进行投影，消除决定属性不是候选键的任何函数依赖。具体可以分为以下几步：</p><ol><li>对1NF关系进行投影，消除原关系中非主属性对键的部分函数依赖，将1NF关系转换成若干个2NF关系。</li><li>对2NF关系进行投影，消除原关系中非主属性对键的传递函数依赖，将2NF关系转换成若干个3NF关系。</li><li>对3NF关系进行投影，消除原关系中主属性对键的部分函数依赖和传递函数依赖，也就是说使决定因素都包含一个候选键。得到一组BCNF关系。</li></ol><p><img src="https://imgtu.com/i/gL1zrt" alt="规范化过程"></p><ul><li>一般情况下，我们说没有异常弊病的数据库设计是好的数据库设计，一个不好的关系模式也总是可以通过分解转换成好的关系模式的集合。</li><li>但是在分解时要全面衡量，综合考虑，视实际情况而定。</li><li>对于那些只要求查询而不要求插入、删除等操作的系统，几种异常现象的存在并不影响数据库的操作。这时便不宜过度分解，否则当要对整体查询时，需要更多的多表连接操作，这有可能得不偿失。****</li><li>在实际应用中，最有价值的是3NF和BCNF，在进行关系模式的设计时，通常分解到3NF就足够了。 </li></ul><h3 id="关系模式规范化的要求"><a href="#关系模式规范化的要求" class="headerlink" title="关系模式规范化的要求"></a>关系模式规范化的要求</h3><ul><li>关系模式的规范化过程是通过对关系模式的投影分解来实现的，但是投影分解方法不是唯一的，不同的投影分解会得到不同的结果。</li><li>在这些分解方法中，只有能够保证分解后的关系模式与原关系模式等价的方法才是有意义的。</li></ul><p><strong>无损连接性（Lossless Join）函数依赖保持性（Preserve Dependency）</strong></p><p>判断分解具有无损连接性的方法</p><ol><li><p>定理判别法 (适合关系模式R分解为两个关系模式R1、R2时)</p><p>若关系模式R&lt;U,F&gt;中，被分解为p={R1&lt;U1,F1&gt;, R2&lt;U2,F2&gt;}是R的一个分解，若R1∩R2 → R1 - R2或者R1∩R2 → R2 - R1，则称p具有无损连接性</p><p>示例：已知R&lt;U,F&gt;,U={A,B,C}，F={B-&gt;C},R的一个分解为R1(A,B)，R2(B,C)</p><p> 解：R1∩R2 为B，R2-R1为C,因为B-&gt;C，因此分解是无损连接</p><blockquote><p>理解：相交的部分能够唯一确定相差的部分得到分解前完整的表</p></blockquote></li><li><p>列表法</p><ul><li>构造一个k行n列的二维表T，第i行对应于一个关系模式Ri，第j列对应于属性Aj，令：tij=aj，若Aj属于Ri；否则tij=bij。</li><li>对于F中一个FD：X→Y，如果表格中有两行在X分量上相等，在Y分量上不相等，那么把这两行在Y分量上改成相等。如果Y的分量中有一个是aj，那么另一个也改成aj；如果没有aj，那么用其中的一个bij替换另一个(尽量把ij改成较小的数，亦即取i值较小的那个)</li><li>若在修改的过程中，发现表格中有一行全是a，即a1,a2,…,an，那么可立即断定p相对于F是无损连接分解，此时不必再继续修改。若经过多次修改直到表格不能修改之后，发现表格中不存在有一行全是a的情况，那么分解就是有损的。特别要注意，这里有个循环反复修改的过程，因为一次修改可能导致表格能继续修改。</li></ul></li></ol><p>判断对关系模式的一个分解是否与原关系模式等价可以有三种不同的标准：</p><ol><li>分解要具有无损连接性。</li><li>分解要具有函数依赖保持性。</li><li>分解既要具有无损连接性，又要具有函数依赖保持性。</li></ol><ul><li>如果一个分解具有无损连接性，则能够保证不丢失信息。如果一个分解具有函数依赖保持性，则可以减轻或解决各种异常情况。</li><li>分解具有无损连接性和函数依赖保持性是两个相互独立的标准。具有无损连接性的分解不一定具有函数依赖保持性。同样，具有函数依赖保持性的分解也不一定具有无损连接性。</li><li>规范化理论提供了一套完整的模式分解方法，按照这套算法可以做到：如果要求分解既具有无损连接性，又具有函数依赖保持性，则<strong>分解一定能够达到3NF，但不一定能够达到BCNF</strong>。</li><li>所以在3NF的规范化中，既要<strong>检查分解是否具有无损连接性，又要检查分解是否具有函数依赖保持性</strong>。只有这两条都满足，才能保证分解的正确性和有效性，才既不会发生信息丢失，又保证关系中的数据满足完整性约束。 </li></ul><h2 id="非规范化设计"><a href="#非规范化设计" class="headerlink" title="非规范化设计"></a>非规范化设计</h2><blockquote><p>许多数据库应用强调性能优先</p><p>规范化设计有时会导致数据库运行效率的下降</p><p>非规范化设计：在特殊条件和要求下，适当地降低甚至抛弃关系模式的范式，不再要求一个表只描述一个实体或者实体间的一种联系。其主要目的在于提高数据库的运行效率。</p></blockquote><p>一般认为，在下列情况下可以考虑进行非规范化处理：</p><ul><li>大量频繁的查询过程所涉及的表都需要进行连接;</li><li>主要的应用程序在执行时要将表连接起来进行查询；</li><li>对数据的计算需要临时表或进行复杂的查询。 </li></ul><p>非规范化处理的主要技术包括<strong>增加冗余或派生列，对表进行合并、分割或增加重复表</strong>。</p><ul><li>增加冗余列是指在多个表中具有相同的列，它常用来在查询时避免连接操作，但它需要更多的磁盘空间，同时增加表维护的工作量。 </li><li>增加派生列指增加的列来自其它表中的数据，由它们计算生成。它的作用是在查询时减少连接操作，避免使用集函数。派生列也具有与冗余列同样的缺点。</li><li>重新组表指如果许多用户需要查看两个表连接出来的结果数据，则把这两个表重新组成一个表来减少连接而提高性能。这样可提高性能，但需要更多的磁盘空间，同时也损失了数据在概念上的独立性。 </li></ul><p>有时<strong>对表做分割</strong>可以提高性能：</p><ul><li><p>水平分割</p><p>根据一列或多列数据的值把数据行放到两个独立的表中。水平分割通常在下面的情况下使用。</p><ul><li>表很大，分割后可以降低在查询时需要读的数据和索引的页数，同时也降低了索引的层数，提高查询速度。</li><li>表中的数据本来就有独立性，例如表中分别记录各个地区的数据或不同时期的数据，特别是有些数据常用，而另外一些数据不常用。</li><li>需要把数据存放到多个介质上。</li></ul><p>水平分割会给应用增加复杂度，它通常在查询时需要多个表名，查询所有数据需要union操作。在许多数据库应用中，这种复杂性会超过它带来的优点。</p></li><li><p>垂直分割</p><p>把主键和一些列放到一个表，然后把主键和另外的列放到另一个表中。</p><p>如果一个表中某些列常用，而另外一些列不常用，则可以采用垂直分割加快查询速度。其缺点是需要管理冗余列，查询所有数据需要join操作。</p></li></ul><p><strong>非规范化设计的主要优点</strong></p><ol><li>减少了查询操作所需的连接</li><li>减少了外部键和索引的数量</li><li>可以预先进行统计计算，提高了查询时的响应速度</li></ol><p><strong>非规范化存在的主要问题</strong></p><ol><li>增加了数据冗余</li><li>影响数据库的完整性</li><li>降低了数据更新的速度</li><li>增加了存储表所占用的物理空间</li></ol><p>无论使用何种非规范化技术，都需要一定的管理来维护数据的完整性</p><p>管理方式有很多，最好的是用<strong>触发器</strong>来实现。对数据的任何修改立即触发对复制列或派生列的相应修改。触发器是实时的，而且相应的处理逻辑只在一个地方出现，易于维护。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>在这一章，我们首先由关系模式的存储异常问题引出了函数依赖的概念，其中包括完全函数依赖、部分函数依赖和传递函数依赖，这些概念是规范化理论的依据和规范化程度的准则。</p><p>规范化就是对原关系进行投影，消除决定属性不是候选键的任何函数依赖。</p><p>一个关系只要其分量都是<strong>不可分</strong>的数据项，就可称作规范化的关系，也称作1NF。</p><p>消除1NF关系中<strong>非主属性对键的部分函数依赖</strong>，得到2NF，消除2NF关系中<strong>非主属性对键的传递函数依赖</strong>，得到3NF，消除3NF关系中<strong>主属性对键的部分函数依赖和传递函数依赖</strong>，便可得到一组BCNF关系。</p><p>在规范化过程中，逐渐消除存储异常，使数据冗余尽量小，便于插入、删除和更新。</p><p>规范化的基本原则就是遵从概念单一化“一事一地”的原则，即一个关系只描述<strong>一个实体或者实体间</strong>的联系。</p><p>规范化的<strong>投影分解方法不是唯一的</strong>，对于3NF的规范化，分解既要具有无损连接性，又要具有函数依赖保持性。</p><p>规范化设计会导致<strong>数据库性能下降</strong>。可以<strong>适当引入非规范化设计</strong>以取得性能上的提高，但需进行精心的数据维护以消除可能带来的数据管理异常</p>]]></content>
      
      
      <categories>
          
          <category> Notes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DataBase </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>线性链表的基本算法</title>
      <link href="2021/0504-xian-xing-lian-biao-de-ji-ben-suan-fa.html"/>
      <url>2021/0504-xian-xing-lian-biao-de-ji-ben-suan-fa.html</url>
      
        <content type="html"><![CDATA[<h1 id="链表的基本操作"><a href="#链表的基本操作" class="headerlink" title="链表的基本操作"></a>链表的基本操作</h1><blockquote><p>说明：以下使用笔者最熟悉的命名方式，元素类型统一为int，链表无头结点</p></blockquote><h3 id="单链表的构造"><a href="#单链表的构造" class="headerlink" title="单链表的构造"></a>单链表的构造</h3><pre class=" language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">include</span><span class="token string">&lt;alloc.h></span></span><span class="token keyword">typedef</span> <span class="token keyword">struct</span> node<span class="token punctuation">{</span>    <span class="token keyword">int</span> val<span class="token punctuation">;</span>    <span class="token keyword">struct</span> node <span class="token operator">*</span>next<span class="token punctuation">;</span><span class="token punctuation">}</span>Node<span class="token punctuation">,</span> <span class="token operator">*</span>list<span class="token punctuation">;</span></code></pre><h3 id="建立一个线性链表"><a href="#建立一个线性链表" class="headerlink" title="建立一个线性链表"></a>建立一个线性链表</h3><pre class=" language-c"><code class="language-c">list <span class="token function">create</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span><span class="token punctuation">{</span>    List p<span class="token punctuation">,</span> q<span class="token punctuation">,</span> head <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//q指向新建立结点，head为表头，p为表尾 </span>    <span class="token keyword">int</span> i<span class="token punctuation">,</span> a<span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>        q <span class="token operator">=</span> <span class="token punctuation">(</span>list<span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>Node<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        q<span class="token operator">-></span>val <span class="token operator">=</span> a<span class="token punctuation">;</span>        q<span class="token operator">-></span>val <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>head <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>            head <span class="token operator">=</span> q<span class="token punctuation">;</span>         <span class="token keyword">else</span>            p<span class="token operator">-></span>next <span class="token operator">=</span> q<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//连接表尾 </span>        p <span class="token operator">=</span> q<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//表尾指针移动 </span>    <span class="token punctuation">}</span>       p<span class="token operator">-></span>next <span class="token operator">=</span> head<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//循环列表加上这一句 </span>    <span class="token keyword">return</span> head<span class="token punctuation">;</span> <span class="token punctuation">}</span> </code></pre><h3 id="求线性链表的长度"><a href="#求线性链表的长度" class="headerlink" title="求线性链表的长度"></a>求线性链表的长度</h3><pre class=" language-c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">length</span><span class="token punctuation">(</span>list head<span class="token punctuation">)</span><span class="token punctuation">{</span>    list p <span class="token operator">=</span> head<span class="token punctuation">;</span>    <span class="token keyword">int</span> cnt <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>p <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        cnt<span class="token operator">++</span><span class="token punctuation">;</span>        p <span class="token operator">=</span> p<span class="token operator">-></span>next<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> cnt<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//递归</span><span class="token keyword">int</span> <span class="token function">length</span><span class="token punctuation">(</span>list head<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>head <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> <span class="token number">1</span> <span class="token operator">+</span> <span class="token function">length</span><span class="token punctuation">(</span>head<span class="token operator">-></span>next<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">else</span>         <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h3 id="判断链表是否为空"><a href="#判断链表是否为空" class="headerlink" title="判断链表是否为空"></a>判断链表是否为空</h3><pre class=" language-c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">isEmpty</span><span class="token punctuation">(</span>list head<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">return</span> head <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h3 id="确定元素在链表中的位置"><a href="#确定元素在链表中的位置" class="headerlink" title="确定元素在链表中的位置"></a>确定元素在链表中的位置</h3><pre class=" language-c"><code class="language-c">list <span class="token function">find</span><span class="token punctuation">(</span>list <span class="token operator">&amp;</span>head<span class="token punctuation">,</span> <span class="token keyword">int</span> item<span class="token punctuation">)</span><span class="token punctuation">{</span>    list p <span class="token operator">=</span> head<span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>p <span class="token operator">!=</span> <span class="token constant">NULL</span> <span class="token operator">&amp;&amp;</span> p<span class="token operator">-></span>val <span class="token operator">!=</span> item<span class="token punctuation">)</span>        p <span class="token operator">=</span> p<span class="token operator">-></span>next<span class="token punctuation">;</span>    <span class="token keyword">return</span> p<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h3 id="在非空链表头插入元素"><a href="#在非空链表头插入元素" class="headerlink" title="在非空链表头插入元素"></a>在非空链表头插入元素</h3><pre class=" language-c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">insert1</span><span class="token punctuation">(</span>list head<span class="token punctuation">,</span> <span class="token keyword">int</span> item<span class="token punctuation">)</span><span class="token punctuation">{</span>    list p <span class="token operator">=</span> <span class="token punctuation">(</span>list<span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>Node<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    p<span class="token operator">-></span>val <span class="token operator">=</span> item<span class="token punctuation">;</span>    p<span class="token operator">-></span>next <span class="token operator">=</span> head<span class="token punctuation">;</span>c    head <span class="token operator">=</span> p<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h3 id="在非空链表尾插入元素"><a href="#在非空链表尾插入元素" class="headerlink" title="在非空链表尾插入元素"></a>在非空链表尾插入元素</h3><pre class=" language-c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">insert2</span><span class="token punctuation">(</span>list <span class="token operator">&amp;</span>head<span class="token punctuation">,</span> <span class="token keyword">int</span> item<span class="token punctuation">)</span><span class="token punctuation">{</span>    list p <span class="token operator">=</span> head<span class="token punctuation">,</span> q<span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>p<span class="token operator">-></span>next <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>        p <span class="token operator">=</span> p<span class="token operator">-></span>next<span class="token punctuation">;</span>    q <span class="token operator">=</span> <span class="token punctuation">(</span>list<span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>Node<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    q<span class="token operator">-></span>val <span class="token operator">=</span> item<span class="token punctuation">;</span>    q<span class="token operator">-></span>next <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>    p<span class="token operator">-></span>next <span class="token operator">=</span> q<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h3 id="在q指向结点后插入元素"><a href="#在q指向结点后插入元素" class="headerlink" title="在q指向结点后插入元素"></a>在q指向结点后插入元素</h3><pre class=" language-c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">insert3</span><span class="token punctuation">(</span>list <span class="token operator">&amp;</span>head<span class="token punctuation">,</span> list q<span class="token punctuation">,</span> <span class="token keyword">int</span> item<span class="token punctuation">)</span><span class="token punctuation">{</span>    list p <span class="token operator">=</span> <span class="token punctuation">(</span>list<span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>Node<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    p<span class="token operator">-></span>val <span class="token operator">=</span> item<span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>head <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        head <span class="token operator">=</span> p<span class="token punctuation">;</span>        p<span class="token operator">-></span>next <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">else</span><span class="token punctuation">{</span>        p<span class="token operator">-></span>next <span class="token operator">=</span> q<span class="token operator">-></span>next<span class="token punctuation">;</span>        q<span class="token operator">-></span>next <span class="token operator">=</span> p<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h3 id="在第i个结点后插入元素"><a href="#在第i个结点后插入元素" class="headerlink" title="在第i个结点后插入元素"></a>在第i个结点后插入元素</h3><pre class=" language-c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">insert4</span><span class="token punctuation">(</span>list <span class="token operator">&amp;</span>head<span class="token punctuation">,</span> <span class="token keyword">int</span> i<span class="token punctuation">,</span> <span class="token keyword">int</span> item<span class="token punctuation">)</span><span class="token punctuation">{</span>    list p <span class="token operator">=</span> head<span class="token punctuation">,</span> q<span class="token punctuation">;</span>    <span class="token keyword">int</span> k <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>k <span class="token operator">&lt;</span> i <span class="token operator">&amp;&amp;</span> p <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        p <span class="token operator">=</span> p<span class="token operator">-></span>next<span class="token punctuation">;</span>        k<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>k <span class="token operator">!=</span> i <span class="token operator">||</span> p <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>        q <span class="token operator">=</span> <span class="token punctuation">(</span>list<span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>Node<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    q<span class="token operator">-></span>val <span class="token operator">=</span> item<span class="token punctuation">;</span>    q<span class="token operator">-></span>next <span class="token operator">=</span> p<span class="token operator">-></span>next<span class="token punctuation">;</span>    p<span class="token operator">-></span>next <span class="token operator">=</span> q<span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h3 id="有序链表插入元素"><a href="#有序链表插入元素" class="headerlink" title="有序链表插入元素"></a>有序链表插入元素</h3><pre class=" language-c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">insert5</span><span class="token punctuation">(</span>list <span class="token operator">&amp;</span>head<span class="token punctuation">,</span> <span class="token keyword">int</span> item<span class="token punctuation">)</span><span class="token punctuation">{</span>    list p<span class="token punctuation">,</span> q<span class="token punctuation">,</span> r<span class="token punctuation">;</span>    q <span class="token operator">=</span> <span class="token punctuation">(</span>list<span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>Node<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    q<span class="token operator">-></span>val <span class="token operator">=</span> item<span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>head <span class="token operator">==</span> <span class="token constant">NULL</span> <span class="token operator">||</span> item <span class="token operator">&lt;</span> head<span class="token operator">-></span>val<span class="token punctuation">)</span><span class="token punctuation">{</span>        q<span class="token operator">-></span>next <span class="token operator">=</span> head<span class="token punctuation">;</span>        head <span class="token operator">=</span> q<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">else</span><span class="token punctuation">{</span>        p <span class="token operator">=</span> head<span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>p <span class="token operator">!=</span> <span class="token constant">NULL</span> <span class="token operator">&amp;&amp;</span> item <span class="token operator">>=</span> p<span class="token operator">-></span>val<span class="token punctuation">)</span><span class="token punctuation">{</span>            r <span class="token operator">=</span> p<span class="token punctuation">;</span>            p <span class="token operator">=</span> p<span class="token operator">-></span>next<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        q<span class="token operator">-></span>next <span class="token operator">=</span> p<span class="token punctuation">;</span>        r<span class="token operator">-></span>next <span class="token operator">=</span> q<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h3 id="非空链表删除q指向的结点"><a href="#非空链表删除q指向的结点" class="headerlink" title="非空链表删除q指向的结点"></a>非空链表删除q指向的结点</h3><pre class=" language-c"><code class="language-c"><span class="token comment" spellcheck="true">//结点q的直接前驱结点未知</span><span class="token keyword">void</span> <span class="token function">delete1</span><span class="token punctuation">(</span>list <span class="token operator">&amp;</span>head<span class="token punctuation">,</span> list q<span class="token punctuation">)</span><span class="token punctuation">{</span>    list p<span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>q <span class="token operator">==</span> head<span class="token punctuation">)</span><span class="token punctuation">{</span>        head <span class="token operator">=</span> head<span class="token operator">-></span>next<span class="token punctuation">;</span>        <span class="token function">free</span><span class="token punctuation">(</span>q<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">else</span><span class="token punctuation">{</span>        p <span class="token operator">=</span> head<span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>p<span class="token operator">-></span>next <span class="token operator">!=</span> q <span class="token operator">&amp;&amp;</span> p<span class="token operator">-></span>next <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>            p <span class="token operator">=</span> p<span class="token operator">-></span>next<span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>p<span class="token operator">-></span>next <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            p<span class="token operator">-></span>next <span class="token operator">=</span> q<span class="token operator">-></span>next<span class="token punctuation">;</span>            <span class="token function">free</span><span class="token punctuation">(</span>q<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h3 id="销毁一个线性链表"><a href="#销毁一个线性链表" class="headerlink" title="销毁一个线性链表"></a>销毁一个线性链表</h3><pre class=" language-c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">deleteList</span><span class="token punctuation">(</span>list <span class="token operator">&amp;</span>head<span class="token punctuation">)</span><span class="token punctuation">{</span>    list p <span class="token operator">=</span> head<span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>p <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        head <span class="token operator">=</span> p<span class="token operator">-></span>next<span class="token punctuation">;</span>        <span class="token function">free</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>        p <span class="token operator">=</span> head<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h3 id="删除值为item的所有结点"><a href="#删除值为item的所有结点" class="headerlink" title="删除值为item的所有结点"></a>删除值为item的所有结点</h3><pre class=" language-c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">delete2</span><span class="token punctuation">(</span>list <span class="token operator">&amp;</span>head<span class="token punctuation">,</span> <span class="token keyword">int</span> item<span class="token punctuation">)</span><span class="token punctuation">{</span>    list p <span class="token operator">=</span> head<span class="token operator">-></span>next<span class="token punctuation">,</span> q <span class="token operator">=</span> head<span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>p <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>p<span class="token operator">-></span>val <span class="token operator">==</span> item<span class="token punctuation">)</span><span class="token punctuation">{</span>            q<span class="token operator">-></span>next <span class="token operator">=</span> p<span class="token operator">-></span>next<span class="token punctuation">;</span>            <span class="token function">free</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>            p <span class="token operator">=</span> q<span class="token operator">-></span>next<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">else</span><span class="token punctuation">{</span>            q <span class="token operator">=</span> p<span class="token punctuation">;</span>            p <span class="token operator">=</span> p<span class="token operator">-></span>next<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>head<span class="token operator">-></span>val <span class="token operator">==</span> item<span class="token punctuation">)</span><span class="token punctuation">{</span>        p <span class="token operator">=</span> head<span class="token punctuation">;</span>        head <span class="token operator">=</span> head<span class="token operator">-></span>next<span class="token punctuation">;</span>        <span class="token function">free</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h3 id="逆转一个线性链表"><a href="#逆转一个线性链表" class="headerlink" title="逆转一个线性链表"></a>逆转一个线性链表</h3><pre class=" language-c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">invert</span><span class="token punctuation">(</span>list <span class="token operator">&amp;</span>head<span class="token punctuation">)</span><span class="token punctuation">{</span>    list p<span class="token punctuation">,</span> q<span class="token punctuation">,</span> r<span class="token punctuation">;</span>    p <span class="token operator">=</span> head<span class="token punctuation">;</span>    q <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>p <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        r <span class="token operator">=</span> q<span class="token punctuation">;</span>        q <span class="token operator">=</span> p<span class="token punctuation">;</span>        p <span class="token operator">=</span> p<span class="token operator">-></span>next<span class="token punctuation">;</span>        q<span class="token operator">-></span>next <span class="token operator">=</span> r<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    head <span class="token operator">=</span> q<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h3 id="两非空线性链表连接"><a href="#两非空线性链表连接" class="headerlink" title="两非空线性链表连接"></a>两非空线性链表连接</h3><pre class=" language-c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">connect</span><span class="token punctuation">(</span>list lista<span class="token punctuation">,</span> list listb<span class="token punctuation">)</span><span class="token punctuation">{</span>    list p <span class="token operator">=</span> lista<span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>p<span class="token operator">-></span>next <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>        p <span class="token operator">=</span> p<span class="token operator">-></span>next<span class="token punctuation">;</span>    p<span class="token operator">-></span>next <span class="token operator">=</span> listb<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h3 id="有序连接"><a href="#有序连接" class="headerlink" title="有序连接"></a>有序连接</h3><pre class=" language-c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">merge</span><span class="token punctuation">(</span>list lista<span class="token punctuation">,</span> list listb<span class="token punctuation">)</span><span class="token punctuation">{</span>    list head<span class="token punctuation">,</span> p <span class="token operator">=</span> lista<span class="token punctuation">,</span> q <span class="token operator">=</span> listb<span class="token punctuation">,</span> r<span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>lista<span class="token operator">-></span>val <span class="token operator">&lt;=</span> listb<span class="token operator">-></span>val<span class="token punctuation">)</span><span class="token punctuation">{</span>        head <span class="token operator">=</span> lista<span class="token punctuation">;</span>        r <span class="token operator">=</span> lista<span class="token punctuation">;</span>        p <span class="token operator">=</span> lista<span class="token operator">-></span>next<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">else</span><span class="token punctuation">{</span>        head <span class="token operator">=</span> listb<span class="token punctuation">;</span>        r <span class="token operator">=</span> listb<span class="token punctuation">;</span>        p <span class="token operator">=</span> listb<span class="token operator">-></span>next<span class="token punctuation">;</span>    <span class="token punctuation">}</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>p <span class="token operator">!=</span> <span class="token constant">NULL</span> <span class="token operator">&amp;&amp;</span> q <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>p<span class="token operator">-></span>val <span class="token operator">&lt;=</span> q<span class="token operator">-></span>val<span class="token punctuation">)</span><span class="token punctuation">{</span>            r<span class="token operator">-></span>next <span class="token operator">=</span> p<span class="token punctuation">;</span>            r <span class="token operator">=</span> p<span class="token punctuation">;</span>            p <span class="token operator">=</span> p<span class="token operator">-></span>next<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">else</span><span class="token punctuation">{</span>            r<span class="token operator">-></span>next <span class="token operator">=</span> q<span class="token punctuation">;</span>            r <span class="token operator">=</span> q<span class="token punctuation">;</span>            q <span class="token operator">=</span> q<span class="token operator">-></span>next<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>        r<span class="token operator">-></span>next <span class="token operator">=</span> p <span class="token operator">?</span> p <span class="token punctuation">:</span> q<span class="token punctuation">;</span>    <span class="token keyword">return</span> head<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h3 id="复制一个线性链表"><a href="#复制一个线性链表" class="headerlink" title="复制一个线性链表"></a>复制一个线性链表</h3><pre class=" language-c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">copy</span><span class="token punctuation">(</span>list head<span class="token punctuation">)</span><span class="token punctuation">{</span>    list head1<span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>head <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>    <span class="token keyword">else</span><span class="token punctuation">{</span>        head1 <span class="token operator">=</span> <span class="token punctuation">(</span>list<span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>Node<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        head1<span class="token operator">-></span>val <span class="token operator">=</span> head<span class="token operator">-></span>val<span class="token punctuation">;</span>        head1<span class="token operator">-></span>next <span class="token operator">=</span> <span class="token function">copy</span><span class="token punctuation">(</span>head<span class="token operator">-></span>next<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> head1<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h3 id="利用线性链表对数组排序"><a href="#利用线性链表对数组排序" class="headerlink" title="利用线性链表对数组排序"></a>利用线性链表对数组排序</h3><pre class=" language-c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">sort</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">)</span><span class="token punctuation">{</span>    list p<span class="token punctuation">,</span> head <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> i<span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token function">insert5</span><span class="token punctuation">(</span>head<span class="token punctuation">,</span> a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    p <span class="token operator">=</span> head<span class="token punctuation">;</span>    i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>p <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        a<span class="token punctuation">[</span>i<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> p<span class="token operator">-></span>val<span class="token punctuation">;</span>        p <span class="token operator">=</span> p<span class="token operator">-></span>next<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h2 id="有关循环列表"><a href="#有关循环列表" class="headerlink" title="有关循环列表"></a>有关循环列表</h2><h3 id="约瑟夫问题（Josephu）"><a href="#约瑟夫问题（Josephu）" class="headerlink" title="约瑟夫问题（Josephu）"></a>约瑟夫问题（Josephu）</h3><pre class=" language-c"><code class="language-c"><span class="token comment" spellcheck="true">//n个人，从k开始，报m出列</span><span class="token keyword">void</span> <span class="token function">solve</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">,</span> <span class="token keyword">int</span> m<span class="token punctuation">,</span> <span class="token keyword">int</span> k<span class="token punctuation">)</span><span class="token punctuation">{</span>    list p<span class="token punctuation">,</span> q<span class="token punctuation">,</span> head <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> i<span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span><span class="token punctuation">{</span>        q <span class="token operator">=</span> <span class="token punctuation">(</span>list<span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>Node<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        q<span class="token operator">-></span>val <span class="token operator">=</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>head <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>            head <span class="token operator">=</span> q<span class="token punctuation">;</span>        <span class="token keyword">else</span>            p<span class="token operator">-></span>next <span class="token operator">=</span> q<span class="token punctuation">;</span>        p <span class="token operator">=</span> q<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    p<span class="token operator">-></span>next <span class="token operator">=</span> head<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//链表创建完毕</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>k<span class="token operator">--</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        q <span class="token operator">=</span> p<span class="token punctuation">;</span>        p <span class="token operator">=</span> p<span class="token operator">-></span>next<span class="token punctuation">;</span>    <span class="token punctuation">}</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>p<span class="token operator">-></span>next <span class="token operator">!=</span> p<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">for</span><span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> m<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span><span class="token punctuation">{</span>            q <span class="token operator">=</span> p<span class="token punctuation">;</span>            p <span class="token operator">=</span> p<span class="token operator">-></span>next<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        q<span class="token operator">-></span>next <span class="token operator">=</span> p<span class="token operator">-></span>next<span class="token punctuation">;</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d\n"</span><span class="token punctuation">,</span> p<span class="token operator">-></span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">free</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>        p <span class="token operator">=</span> q<span class="token operator">-></span>next<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"最后一个结点的编号为%d\n"</span><span class="token punctuation">,</span> p<span class="token operator">-></span>val<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h2 id="有关双向列表"><a href="#有关双向列表" class="headerlink" title="有关双向列表"></a>有关双向列表</h2><h3 id="构造"><a href="#构造" class="headerlink" title="构造"></a>构造</h3><pre class=" language-c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> node<span class="token punctuation">{</span>    <span class="token keyword">int</span> val<span class="token punctuation">;</span>    <span class="token keyword">struct</span> node <span class="token operator">*</span>left<span class="token punctuation">;</span>    <span class="token keyword">struct</span> node <span class="token operator">*</span>right<span class="token punctuation">;</span><span class="token punctuation">}</span>Node<span class="token punctuation">,</span> <span class="token operator">*</span>List<span class="token punctuation">;</span>  </code></pre><h3 id="在带头结点的双向循环列表中的第一个数据域内容为x的结点右边插入元素"><a href="#在带头结点的双向循环列表中的第一个数据域内容为x的结点右边插入元素" class="headerlink" title="在带头结点的双向循环列表中的第一个数据域内容为x的结点右边插入元素"></a>在带头结点的双向循环列表中的第一个数据域内容为x的结点右边插入元素</h3><pre class=" language-c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">insertD</span><span class="token punctuation">(</span>Dlist head<span class="token punctuation">,</span> <span class="token keyword">int</span> x<span class="token punctuation">,</span> <span class="token keyword">int</span> item<span class="token punctuation">)</span><span class="token punctuation">{</span>    Dlist p<span class="token punctuation">,</span> q<span class="token punctuation">;</span>    p <span class="token operator">=</span> head<span class="token operator">-></span>right<span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>p <span class="token operator">!=</span> head <span class="token operator">&amp;&amp;</span> p<span class="token operator">-></span>val <span class="token operator">!=</span> x<span class="token punctuation">)</span><span class="token punctuation">{</span>        p <span class="token operator">=</span> p<span class="token operator">-></span>right<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>p <span class="token operator">==</span> head<span class="token punctuation">)</span>        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>            q <span class="token operator">=</span> <span class="token punctuation">(</span>Dlist<span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>Dnode<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    q<span class="token operator">-></span>val <span class="token operator">=</span> item<span class="token punctuation">;</span>    q<span class="token operator">-></span>right <span class="token operator">=</span> p<span class="token operator">-></span>right<span class="token punctuation">;</span>    q<span class="token operator">-></span>left <span class="token operator">=</span> p<span class="token punctuation">;</span>        p<span class="token operator">-></span>right <span class="token operator">=</span> q<span class="token punctuation">;</span>    q<span class="token operator">-></span>right<span class="token operator">-></span>left <span class="token operator">=</span> q<span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><pre class=" language-c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">deleteD</span><span class="token punctuation">(</span>Dlist head<span class="token punctuation">,</span> <span class="token keyword">int</span> x<span class="token punctuation">,</span> <span class="token keyword">int</span> item<span class="token punctuation">)</span><span class="token punctuation">{</span>    Dlist p<span class="token punctuation">,</span> q<span class="token punctuation">;</span>    p <span class="token operator">=</span> head<span class="token operator">-></span>right<span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>p <span class="token operator">!=</span> head <span class="token operator">&amp;&amp;</span> p<span class="token operator">-></span>val <span class="token operator">!=</span> x<span class="token punctuation">)</span><span class="token punctuation">{</span>        p <span class="token operator">=</span> p<span class="token operator">-></span>right<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>p <span class="token operator">==</span> head<span class="token punctuation">)</span>        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>            p<span class="token operator">-></span>right<span class="token operator">-></span>left <span class="token operator">=</span> p<span class="token operator">-></span>left<span class="token punctuation">;</span>    p<span class="token operator">-></span>left<span class="token operator">-></span>right <span class="token operator">=</span> p<span class="token operator">-></span>right<span class="token punctuation">;</span>    <span class="token function">free</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> Summary </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Data Structure </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>理解inode</title>
      <link href="2021/0425-li-jie-inode.html"/>
      <url>2021/0425-li-jie-inode.html</url>
      
        <content type="html"><![CDATA[<h1 id="理解inode"><a href="#理解inode" class="headerlink" title="理解inode"></a>理解inode</h1><h3 id="inode是什么？"><a href="#inode是什么？" class="headerlink" title="inode是什么？"></a>inode是什么？</h3><p>理解inode，要从文件储存说起。</p><p>文件储存在硬盘上，硬盘的最小存储单位叫做”扇区”（Sector）。每个扇区储存512字节（相当于0.5KB）。</p><p>操作系统读取硬盘的时候，不会一个个扇区地读取，这样效率太低，而是一次性连续读取多个扇区，即一次性读取一个”块”（block）。这种由多个扇区组成的”块”，是文件存取的最小单位。”块”的大小，最常见的是4KB，即连续八个 sector组成一个 block。</p><p>文件数据都储存在”块”中，那么很显然，我们还必须找到一个地方储存文件的元信息，比如文件的创建者、文件的创建日期、文件的大小等等。这种储存文件元信息的区域就叫做inode，中文译名为”索引节点”。</p><p>每一个文件都有对应的inode，里面包含了与该文件有关的一些信息。</p><h2 id="inode的内容"><a href="#inode的内容" class="headerlink" title="inode的内容"></a>inode的内容</h2><p>inode包含文件的元信息，具体来说有以下内容：</p><pre class=" language-text"><code class="language-text">* 文件的字节数* 文件拥有者的User ID* 文件的Group ID* 文件的读、写、执行权限* 文件的时间戳，共有三个：ctime指inode上一次变动的时间，mtime指文件内容上一次变动的时间，atime指文件上一次打开的时间。* 链接数，即有多少文件名指向这个inode* 文件数据block的位置</code></pre><p>可以用stat命令，查看某个文件的inode信息：</p><pre class=" language-bash"><code class="language-bash"><span class="token function">stat</span> example</code></pre><p>![](<a href="https://imgtu.com/i/cvbXCT">stat addowner.sh</a>)</p><p>总之，除了文件名以外的所有文件信息，都存在inode之中。至于为什么没有文件名，下文会有详细解释。</p><h3 id="inode的大小"><a href="#inode的大小" class="headerlink" title="inode的大小"></a>inode的大小</h3><p>inode也会消耗硬盘空间，所以硬盘格式化的时候，操作系统自动将硬盘分成两个区域。一个是数据区，存放文件数据；另一个是inode区（inode table），存放inode所包含的信息。</p><p>每个inode节点的大小，一般是128字节或256字节。inode节点的总数，在格式化时就给定，一般是每1KB或每2KB就设置一个inode。假定在一块1GB的硬盘中，每个inode节点的大小为128字节，每1KB就设置一个inode，那么inode table的大小就会达到128MB，占整块硬盘的12.8%。</p><p>查看每个硬盘分区的inode总数和已经使用的数量，可以使用df命令。</p><pre class=" language-bash"><code class="language-bash"><span class="token function">df</span> -i</code></pre><p>![](<a href="https://imgtu.com/i/cvqpr9">df -i</a>)</p><p>查看每个inode节点的大小，可以用如下命令：</p><pre class=" language-bash"><code class="language-bash"><span class="token function">sudo</span> dumpe2fs -h /dev/hda <span class="token operator">|</span> <span class="token function">grep</span> <span class="token string">"Inode size"</span></code></pre><p>由于每个文件都必须有一个inode，因此有可能发生inode已经用光，但是硬盘还未存满的情况。这时，就无法在硬盘上创建新文件。</p><h3 id="inode号码"><a href="#inode号码" class="headerlink" title="inode号码"></a>inode号码</h3><p>每个inode都有一个号码，操作系统用inode号码来识别不同的文件。</p><p>这里值得重复一遍，Unix/Linux系统内部不使用文件名，而使用inode号码来识别文件。对于系统来说，文件名只是inode号码便于识别的别称或者绰号。</p><p>表面上，用户通过文件名，打开文件。实际上，系统内部这个过程分成三步：首先，系统找到这个文件名对应的inode号码；其次，通过inode号码，获取inode信息；最后，根据inode信息，找到文件数据所在的block，读出数据。</p><p>使用ls -i命令，可以看到文件名对应的inode号码：</p><p>![](<a href="https://imgtu.com/i/cvqF56">ls -i</a>)</p><h3 id="目录文件"><a href="#目录文件" class="headerlink" title="目录文件"></a>目录文件</h3><p>Unix/Linux系统中，目录（directory）也是一种文件。打开目录，实际上就是打开目录文件。</p><p>目录文件的结构非常简单，就是一系列目录项（dirent）的列表。每个目录项，由两部分组成：<strong>所包含文件的文件名，以及该文件名对应的inode号码</strong>。</p><p>ls命令只列出目录文件中的所有文件名：</p><pre class=" language-bash"><code class="language-bash"><span class="token function">ls</span> /etc</code></pre><p>ls -i命令列出整个目录文件，即文件名和inode号码：</p><pre class=" language-bash"><code class="language-bash"><span class="token function">ls</span> -i /etc</code></pre><p>如果要查看文件的详细信息，就必须根据inode号码，访问inode节点，读取信息。ls -l命令列出文件的详细信息。</p><pre class=" language-bash"><code class="language-bash"><span class="token function">ls</span> -l /etc</code></pre><p>理解了上面这些知识，就能理解目录的权限。目录文件的读权限（r）和写权限（w），都是针对目录文件本身。由于目录文件内只有文件名和inode号码，所以如果只有读权限，只能获取文件名，无法获取其他信息，因为其他信息都储存在inode节点中，而读取inode节点内的信息需要目录文件的执行权限（x）。</p><h3 id="硬链接"><a href="#硬链接" class="headerlink" title="硬链接"></a>硬链接</h3><p>一般情况下，文件名和inode号码是”一一对应”关系，每个inode号码对应一个文件名。但是，Unix/Linux系统允许，多个文件名指向同一个inode号码。</p><p>这意味着，<strong>可以用不同的文件名访问同样的内容；对文件内容进行修改，会影响到所有文件名；但是，删除一个文件名，不影响另一个文件名的访问</strong>。这种情况就被称为”硬链接”（hard link）。</p><p>ln命令可以创建硬链接：</p><pre class=" language-bash"><code class="language-bash"><span class="token function">ln</span> 源文件 目标文件</code></pre><p><img src="%5Bln%5D(https://imgtu.com/i/cvqmKH)"></p><p>运行上面这条命令以后，源文件与目标文件的inode号码相同，都指向同一个inode。inode信息中有一项叫做”链接数”，记录指向该inode的文件名总数，这时就会增加1。</p><p>反过来，删除一个文件名，就会使得inode节点中的”链接数”减1。<strong>当这个值减到0，表明没有文件名指向这个inode，系统就会回收这个inode号码，以及其所对应block区域</strong>。</p><p>这里顺便说一下目录文件的”链接数”。创建目录时，默认会生成两个目录项：”.”和”..”。前者的inode号码就是当前目录的inode号码，等同于当前目录的”硬链接”；后者的inode号码就是当前目录的父目录的inode号码，等同于父目录的”硬链接”。所以，<strong>任何一个目录的”硬链接”总数，总是等于2加上它的子目录总数（含隐藏目录）</strong>。</p><h3 id="软链接"><a href="#软链接" class="headerlink" title="软链接"></a>软链接</h3><p>除了硬链接以外，还有一种特殊情况。</p><p>文件A和文件B的inode号码虽然不一样，但是文件A的内容是文件B的路径。读取文件A时，系统会自动将访问者导向文件B。因此，无论打开哪一个文件，最终读取的都是文件B。这时，文件A就称为文件B的”软链接”（soft link）或者”符号链接（symbolic link）。</p><p>这意味着，文件A依赖于文件B而存在，如果删除了文件B，打开文件A就会报错：”No such file or directory”。这是软链接与硬链接最大的不同：<strong>文件A指向文件B的文件名，而不是文件B的inode号码，文件B的inode”链接数”不会因此发生变化</strong>。</p><p>ln -s命令可以创建软链接。</p><pre class=" language-bash"><code class="language-bash"><span class="token function">ln</span> -s 源文文件或目录 目标文件或目录</code></pre><p>![](<a href="https://imgtu.com/i/cvqQat">ln -s</a>)</p><h3 id="inode的特殊作用"><a href="#inode的特殊作用" class="headerlink" title="inode的特殊作用"></a>inode的特殊作用</h3><p>由于inode号码与文件名分离，这种机制导致了一些Unix/Linux系统特有的现象。</p><p>　　1. 有时，文件名包含特殊字符，无法正常删除。这时，<strong>直接删除inode节点，就能起到删除文件的作用</strong>。</p><p>　　2. 移动文件或重命名文件，只是改变文件名，不影响inode号码。</p><p>　　3. 打开一个文件以后，系统就以inode号码来识别这个文件，不再考虑文件名。因此，通常来说，<strong>系统无法从inode号码得知文件名</strong>。</p><p>第3点使得软件更新变得简单，可以在不关闭软件的情况下进行更新，不需要重启。因为系统通过inode号码，识别运行中的文件，不通过文件名。更新的时候，新版文件以同样的文件名，生成一个新的inode，不会影响到运行中的文件。等到下一次运行这个软件的时候，文件名就自动指向新版文件，旧版文件的inode则被回收。</p><p>（完）</p><p>转载于<a href="http://www.ruanyifeng.com/blog/2011/12/inode.html">理解inode-阮一峰的网络日志</a></p>]]></content>
      
      
      <categories>
          
          <category> Notes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 系统编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java-polymorphism</title>
      <link href="2021/0416java-polymorphism.html"/>
      <url>2021/0416java-polymorphism.html</url>
      
        <content type="html"><![CDATA[<h1 id="Java-多态-polymorphism"><a href="#Java-多态-polymorphism" class="headerlink" title="Java-多态(polymorphism)"></a>Java-多态(polymorphism)</h1><h3 id="为什么会出现多态"><a href="#为什么会出现多态" class="headerlink" title="为什么会出现多态?"></a>为什么会出现多态?</h3><ul><li><p>Java 中的引用变量有两个类型：</p><ul><li><strong>一个是编译时的类型，一个是运行时的类型，</strong> 编译时的类型由声明该变量时使用的类型决定， 运行时的类型由实际赋给该变量的对象决定。</li></ul></li><li><p><u>如果编译时的类型与运行时的类型不一致就会出现所谓的多态？</u></p></li></ul><h3 id="多态性"><a href="#多态性" class="headerlink" title="多态性"></a>多态性</h3><ul><li>概念：是面向对象程序设计的另一个重要特征， 其基本含义是“拥有多种形态”，具体指在程序 中用相同的名称来表示不同的含义。例如：用同一方法名来表示不同的操作 </li><li>类型：有两种 <ul><li>静态多态性：包括隐藏、方法的<u>重载</u> </li><li>动态多态性：在编译时不能确定所要调用的方法，只有在运行时才能确定所要调用的方法，又称为<strong>运行时的多态性</strong></li></ul></li></ul><h4 id="静态多态（静多态）"><a href="#静态多态（静多态）" class="headerlink" title="静态多态（静多态）"></a>静态多态（静多态）</h4><ul><li>静态多态：即在编译时决定调用哪个方法，也称为编译时多态，也称为静态联编，也称为静绑定； </li><li>静态多态一般是指<strong>方法重载，方法隐藏</strong>； </li><li>只要构成了方法重载，就可以认为形成了静态多态的条件；因此，<strong>静态多态与是否发生继承没有必然联系</strong>。</li></ul><h5 id="方法重载（Overloading）"><a href="#方法重载（Overloading）" class="headerlink" title="方法重载（Overloading）"></a>方法重载（Overloading）</h5><ul><li>方法重载：Java允许在一个类中定义多个<strong>同名</strong>的方法，但这些方法的<strong>参数列表必须不同</strong> <ul><li>方法名相同，<strong>参数个数、参数类型及参数顺序至少有一个不同</strong> </li></ul></li><li>重载的目的：一般是为了创建一组要完成相似任务的成员方法。 </li><li>构造方法和静态成员方法都是可以重载，<strong>静态成员方法重载后的方法也可以是非静态成员方法</strong>（不能被重写成非静态！）。</li></ul><p>⚫ 注意1：对于方法重载，返回值类型与访问权限修饰符可以相同也可以不同，上述两项不能当做判断是否重载的条件。 </p><p>⚫ 注意2：如果一个类中有两个同名方法，其参数列表完全一样，<strong>仅仅返回值类型不同</strong>，则编译时会 产生错误</p><h4 id="动态多态（动多态）"><a href="#动态多态（动多态）" class="headerlink" title="动态多态（动多态）"></a>动态多态（动多态）</h4><ul><li>方法覆盖是子类的成员方法重写了父类的成员方法，重写的目的很大程度上是为了实现多态；</li><li> 动态多态：即在运行时才能确定调用哪个方法，也称为运行时多态，也称为动态联编，也称为动绑定； </li><li>Java中，实现（动）多态有3个条件：<strong>继承、覆盖、向上转型</strong>，缺一不可。 <ul><li>“覆盖(override)方法、抽象方法和接口” 和动态联编关系紧密</li></ul></li></ul><h5 id="Java形成动态多态必须具备以下条件："><a href="#Java形成动态多态必须具备以下条件：" class="headerlink" title="Java形成动态多态必须具备以下条件："></a>Java形成动态多态必须具备以下条件：</h5><ul><li> Java形成动态多态必须具备以下条件： </li></ul><p>  ① 必须要有继承的情况存在； </p><p>  ② 在继承中必须要有方法覆盖； </p><p>  ③ 必须由父类的引用指向派生类的实例，并且通过父类的引用调用被覆盖的方法； </p><ul><li>由上述条件可以看出，<strong>继承是实现动态多态的首要前提</strong>。</li></ul><h5 id="方法覆盖（override）"><a href="#方法覆盖（override）" class="headerlink" title="方法覆盖（override）"></a>方法覆盖（override）</h5><ul><li><p>方法覆盖：方法名、参数个数、参数类型及参数顺序必须一致； </p></li><li><p>若父类方法定义时有异常抛出，则子类覆盖父类该方法时时，<strong>该方法也不能有更多的异常抛出</strong>，否则编译时会产生错误</p></li><li><p>子类方法不能缩小父类方法的访问权限： </p><p>a) 一个package方法可以被重写为package、 protected和public的； </p><p>b) 一个protected方法可以被重写为protected和public的； </p><p>c) 一个public方法只可以被重写为public的；</p><p>② <strong>私有方法、静态方法不能被覆盖</strong>，如果在子类出现了同签名的方法，就是方法隐藏； </p><p>③ 父类中，被final修饰的方法是最终方法，不允许覆盖。</p></li></ul><h3 id="多态的实现：通过继承实现"><a href="#多态的实现：通过继承实现" class="headerlink" title="多态的实现：通过继承实现"></a>多态的实现：通过继承实现</h3><ul><li>Java中，一个类只能有一个父类，不能多继承。 </li><li>Java中，一个父类可以有多个子类，而在子类里可以覆盖父类的方法。 </li><li>当用父类的变量去引用不同的子类，在调用这个相同的方法的时候得到的结果和表现形式就不一样了，这就是多态，相同的消息（也就是调用相同的方法）会有不同的结果</li></ul><h3 id="采用多态技术的优点"><a href="#采用多态技术的优点" class="headerlink" title="采用多态技术的优点"></a>采用多态技术的优点</h3><ul><li>引进多态技术之后，尽管子类的对象千差万别，但都可以采用 <u>父类引用.方法名([参数]) 统一</u> 方式来调用，在程序运行时能根据子对象的不同得到不同的结果。 </li><li>应用程序不必为每一个派生类（子类）编写功能调用，只需要对抽象基类进行处理即可。这种“<strong>以不变应万变</strong>”的形式可以规范、简化程序设计，符合软件工程的“一个接口，多种方法”思想，可以大大提高程序的可复用性。 </li><li>派生类的功能可以被基类的引用变量引用，这叫<strong>向后兼容</strong>，可以提高程序的可扩充性和可维护性。</li></ul><h3 id="多态的运行机制（-）"><a href="#多态的运行机制（-）" class="headerlink" title="多态的运行机制（*）"></a>多态的运行机制（*）</h3><ul><li><p>Java多态机制是基于“方法绑定（binding）”，就是建立method call（方法调用）和method body（方法本体）的关联。 </p></li><li><p>如果绑定动作发生于程序执行前（由编译器和连接器完成），称为“先期绑定”或者早绑定。</p><ul><li>对于面向过程的语言它们没有其他选择，一定是先期绑定。比如C编译器只有一种method call，就是先期绑定。（C++有先期联编和后期联编）</li></ul></li><li><p>在编译阶段能够确定方法在内存什么位置的机制就叫静态绑定机制 </p></li><li><p><u>所有私有方法、静态方法、构造器及final修饰方法都是采用静态绑定机制</u>。在编译器阶段就已经指明了调用方法在常量池中的符号引用，JVM运行的时候只需要进行一次常量池解析即可</p></li><li><p>当有动多态的情况时，解决方案便是所谓的后期绑定（late binding）即晚绑定：绑定动作将在执行期根据对象类型而进行。 </p></li><li><p>后期绑定也被称为执行期绑定（run-time  binding）或动态绑定（dynamic binding）。</p></li><li><p>对于Java当中的方法而言，final，static， private修饰的方法和构造方法是前期绑定。 </p></li><li><p>Java中，<strong>所有的private方法都被隐式的指定为final的</strong>。 </p></li><li><p>将方法声明为final类型的一是为了防止方法被覆盖，二是为了有效的关闭java中的动态绑定。或者说，<u>这么做便是告诉编译器： 动态绑定是不需要的</u>。于是编译器可以产生效率较佳的程序代码。</p></li></ul><h3 id="题外话：关于抽象类和抽象方法"><a href="#题外话：关于抽象类和抽象方法" class="headerlink" title="题外话：关于抽象类和抽象方法"></a>题外话：关于抽象类和抽象方法</h3><h4 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h4><p>一． 如果一个类继承自某个抽象父类，而没有具体实现抽象父类中的抽象方法，则必须定义为抽象类。 </p><p>二． <strong>抽象类是不能实例化的</strong>，但可以创建它的引用。它的作用是提供一个恰当的父类。因此一般作为其它类的超类,与final类正好相反。 </p><p>三． 如果一个类里有抽象的方法，则这个类就必须声明成抽象的。但一个抽象类中却可以没有抽象方法。</p><ul><li><p>抽象方法不能被private、final或static修饰。为什么？ </p><p>① 抽象方法必须被子类所覆盖，如果说明为 private，则外部无法访问，覆盖也无从谈起。 </p><p>② 若说明为static，即使不创建对象也能访问： 类名.方法名() ，这要求给出方法体，但与抽象方法的定义相矛盾。 </p><p>③ Final和abstract含义矛盾 </p></li><li><p>当类实现了一个接口，但<strong>并没有实现该接口的所有方法时，该类必须声明为抽象类</strong>，否则出错；</p></li></ul><h3 id="小结：多态的优点："><a href="#小结：多态的优点：" class="headerlink" title="小结：多态的优点："></a>小结：多态的优点：</h3><ul><li>应用程序不必为每一个派生类（子类）编写功能调用，只需要对抽象基类进行处理即可。这一招叫 “<strong>以不变应万变</strong>”，可以大大提高程序的可复用性。 </li><li>派生类的功能可以被基类的引用变量引用，这叫<strong>向后兼容</strong>，可以提高程序的可扩充性和可维护性，程序的调用界面清楚，可读性好，并解决代码冗余。</li></ul><h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><p>在Java语言中，接口有两种意思：</p><ol><li>一是指概念性的接口，即指类对外提供的所有服务。<strong>类的所有能被其他程序访问的方法</strong>构成了类的接口。</li><li>二是指用<strong>interface关键字</strong>定义的实实在在的接口，也称为接口类型。Java接口是一系列方法的声明，是一些方法特征的集合，一个接口只有方法的特征没有方法的实现，因此这些方法可以在不同的地方被不同的类实现，而这些实现可以具有不同的行为（功能）</li></ol><p><strong>接口的概念</strong></p><ul><li>从本质上讲，接口是一种特殊的抽象类，这种抽象类中只包含常量和方法的定义，而没有方法的实现。接口是抽象方法和常量值的定义的集合。</li><li>接口是用来实现类间（不相关类）多重继承功能的结构。</li><li>从语法上看，接口是一种与“类”很相似的结构，只是接口中的所有方法都是抽象的，只有声明、没有方法体。</li><li>接口声明的关键字是interface。</li></ul><p><strong>接口要点：</strong></p><ol><li>接口是Java中的一种复合数据类型，是用interface关键字来定义的；</li><li>接口是一种特殊的“类” ，一种特殊的“抽象类”；</li><li>接口中所有的方法都默认是<strong>public abstract</strong>的，并且只有方法头和参数列表，没有方法体；</li><li>接口中所有的变量都默认是<strong>public static final</strong>的；</li><li>接口中没有构造方法；</li><li>一个类可以实现多个接口。</li><li>接口中的方法体可以由 java 语言书写，也可以由其他语言书写，用其他语言书写时，接口方法需要用 native关键字修饰</li></ol><p><strong>注意：</strong></p><ol><li>一个类在实现某个接口的抽象方法时，必须以完全相同的方法头。否则，只是在重载一个新方法，而不是实现已有的抽象方法。</li><li>接口的抽象方法的访问限制符默认为 public，所以类在实现这些抽象方法时，必须显式的使用 public 修饰符，否则将被警告为缩小了接口中定义的方法的访问控制权限</li></ol><p>接口的使用：将接口作为类型</p><p>如果一个方法的参数是接口类型，就可以将<strong>任何实现该接口的类的实例的引用传递给接口参数</strong>，那么接口参数就可以<strong>回调类实现的接口方法</strong>。</p><p><strong>接口可以继承，而且可以多重继承</strong></p><p>相同：</p><p>抽象类与接口都是为了继承与多态，它们都需要子类来继承或实现才有意义，最终目的是为了多态；<strong>子类重写了父类的方法，再通过向上转型，由父类对象引用指向子类对象，达到运行时动态调用子类方法的目的</strong>。</p><p>抽象类和接口的<strong>区别</strong>：</p><ul><li>接口中的成员变量和方法只能是public类型的，而抽象类中的成员变量和方法可以处于各种访 问级别。</li><li>接口中的成员变量只能是public、static和final类型的，而在抽象类中可以定义各种类型的实例变量和静态变量。</li><li>接口中没有构造方法，抽象类中有构造方法。接口中所有方法都是抽象方法，抽象类中可以有，也可以没有抽象方法。抽象类比接口包含了更多的实现细节。</li><li>抽象类是某一类事物的一种抽象，而接口不是类，它只定义了某些行为；</li><li>在语义上，接口表示<strong>更高层次</strong>的抽象，声明系统对外提供的服务。而抽象类则是各种具体类型的抽象。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Notes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二分与前缀和</title>
      <link href="2021/0415-er-fen-yu-qian-zhui-he.html"/>
      <url>2021/0415-er-fen-yu-qian-zhui-he.html</url>
      
        <content type="html"><![CDATA[<h1 id="二分与前缀和"><a href="#二分与前缀和" class="headerlink" title="二分与前缀和"></a>二分与前缀和</h1><h2 id="AcWing-789-数的范围"><a href="#AcWing-789-数的范围" class="headerlink" title="AcWing 789.数的范围"></a>AcWing 789.数的范围</h2><p>给定一个按照升序排列的长度为 n 的整数数组，以及 q 个查询。</p><p>对于每个查询，返回一个元素 k 的起始位置和终止位置（位置从 0 开始计数）。</p><p>如果数组中不存在该元素，则返回 <code>-1 -1</code>。</p><h4 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h4><p>第一行包含整数 n 和 q，表示数组长度和询问个数。</p><p>第二行包含 n 个整数（均在 1∼10000 范围内），表示完整数组。</p><p>接下来 q 行，每行包含一个整数 k，表示一个询问元素。</p><h4 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h4><p>共 q 行，每行包含两个整数，表示所求元素的起始位置和终止位置。</p><p>如果数组中不存在该元素，则返回 <code>-1 -1</code>。</p><h4 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h4><p>1≤n≤100000<br>1≤q≤10000<br>1≤k≤10000</p><h4 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h4><pre class=" language-text"><code class="language-text">6 31 2 2 3 3 4345</code></pre><h4 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h4><pre class=" language-text"><code class="language-text">3 45 5-1 -1</code></pre><pre class=" language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span><span class="token string">&lt;iostream></span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token macro property">#<span class="token directive keyword">define</span> N 100010</span><span class="token keyword">int</span> n<span class="token punctuation">,</span> q<span class="token punctuation">,</span> m<span class="token punctuation">,</span> a<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">findl</span><span class="token punctuation">(</span><span class="token keyword">int</span> k<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> l <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> r <span class="token operator">=</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> mid<span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>l <span class="token operator">&lt;=</span> r<span class="token punctuation">)</span><span class="token punctuation">{</span>        mid <span class="token operator">=</span> <span class="token punctuation">(</span>l <span class="token operator">+</span> r<span class="token punctuation">)</span> <span class="token operator">>></span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>a<span class="token punctuation">[</span>mid<span class="token punctuation">]</span> <span class="token operator">&lt;</span> k<span class="token punctuation">)</span>            l <span class="token operator">=</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">else</span> r <span class="token operator">=</span> mid <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>a<span class="token punctuation">[</span>l<span class="token punctuation">]</span> <span class="token operator">!=</span> k<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> l<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">findr</span><span class="token punctuation">(</span><span class="token keyword">int</span> k<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> l <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> r <span class="token operator">=</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> mid<span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>l <span class="token operator">&lt;=</span> r<span class="token punctuation">)</span><span class="token punctuation">{</span>        mid <span class="token operator">=</span> <span class="token punctuation">(</span>l <span class="token operator">+</span> r<span class="token punctuation">)</span> <span class="token operator">>></span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>a<span class="token punctuation">[</span>mid<span class="token punctuation">]</span> <span class="token operator">&lt;=</span> k<span class="token punctuation">)</span>            l <span class="token operator">=</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">else</span> r <span class="token operator">=</span> mid <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>a<span class="token punctuation">[</span>r<span class="token punctuation">]</span> <span class="token operator">!=</span> k<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> r<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    cin <span class="token operator">>></span> n <span class="token operator">>></span> q<span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>        cin <span class="token operator">>></span> a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>q<span class="token operator">--</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        cin <span class="token operator">>></span> m<span class="token punctuation">;</span>        cout <span class="token operator">&lt;&lt;</span> <span class="token function">findl</span><span class="token punctuation">(</span>m<span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token string">" "</span> <span class="token operator">&lt;&lt;</span> <span class="token function">findr</span><span class="token punctuation">(</span>m<span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h2 id="AcWing-1221-四平方和"><a href="#AcWing-1221-四平方和" class="headerlink" title="AcWing 1221.四平方和"></a>AcWing 1221.四平方和</h2><p>四平方和定理，又称为拉格朗日定理：</p><p>每个正整数都可以表示为至多 4 个正整数的平方和。</p><p>如果把 0 包括进去，就正好可以表示为 4 个数的平方和。</p><p>比如：</p><p>$5=0^2+0^2+1^2+2^2$<br>$7=1^2+1^2+1^2+2^2$</p><p>对于一个给定的正整数，可能存在多种平方和的表示法。</p><p>要求你对 44 个数排序：</p><p>$0≤a≤b≤c≤d$</p><p>并对所有的可能表示法按 $a,b,c,d$ 为联合主键升序排列，最后输出第一个表示法。</p><h4 id="输入格式-1"><a href="#输入格式-1" class="headerlink" title="输入格式"></a>输入格式</h4><p>输入一个正整数 N。</p><h4 id="输出格式-1"><a href="#输出格式-1" class="headerlink" title="输出格式"></a>输出格式</h4><p>输出4个非负整数，按从小到大排序，中间用空格分开。</p><h4 id="数据范围-1"><a href="#数据范围-1" class="headerlink" title="数据范围"></a>数据范围</h4><p>$0&lt;N&lt;5∗10^6$</p><h4 id="输入样例：-1"><a href="#输入样例：-1" class="headerlink" title="输入样例："></a>输入样例：</h4><pre class=" language-text"><code class="language-text">5</code></pre><h4 id="输出样例：-1"><a href="#输出样例：-1" class="headerlink" title="输出样例："></a>输出样例：</h4><pre class=" language-text"><code class="language-text">0 0 1 2</code></pre><pre class=" language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">//二分✔</span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;cstring></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;algorithm></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;cmath></span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token macro property">#<span class="token directive keyword">define</span> N 2500010</span><span class="token keyword">struct</span> node<span class="token punctuation">{</span>    <span class="token keyword">int</span> s<span class="token punctuation">,</span> c<span class="token punctuation">,</span> d<span class="token punctuation">;</span>    <span class="token keyword">bool</span> <span class="token keyword">operator</span><span class="token operator">&lt;</span> <span class="token punctuation">(</span><span class="token keyword">const</span> node <span class="token operator">&amp;</span>t<span class="token punctuation">)</span><span class="token keyword">const</span><span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>s <span class="token operator">==</span> t<span class="token punctuation">.</span>s<span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>c <span class="token operator">==</span> t<span class="token punctuation">.</span>c<span class="token punctuation">)</span> <span class="token keyword">return</span> d <span class="token operator">&lt;</span> t<span class="token punctuation">.</span>d<span class="token punctuation">;</span>            <span class="token keyword">else</span> <span class="token keyword">return</span> c <span class="token operator">&lt;</span> t<span class="token punctuation">.</span>c<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">else</span> <span class="token keyword">return</span> s <span class="token operator">&lt;</span> t<span class="token punctuation">.</span>s<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span>sum<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">int</span> n<span class="token punctuation">,</span> cnt<span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    cin <span class="token operator">>></span> n<span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> c <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> c <span class="token operator">*</span> c <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>c<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> d <span class="token operator">=</span> c<span class="token punctuation">;</span> c <span class="token operator">*</span> c <span class="token operator">+</span> d <span class="token operator">*</span> d <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>d<span class="token punctuation">)</span><span class="token punctuation">{</span>            sum<span class="token punctuation">[</span>cnt<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span>c <span class="token operator">*</span> c <span class="token operator">+</span> d <span class="token operator">*</span> d<span class="token punctuation">,</span> c<span class="token punctuation">,</span> d<span class="token punctuation">}</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token function">sort</span><span class="token punctuation">(</span>sum<span class="token punctuation">,</span> sum <span class="token operator">+</span> cnt<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> a <span class="token operator">*</span> a <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>a<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> b <span class="token operator">=</span> a<span class="token punctuation">;</span> a <span class="token operator">*</span> a <span class="token operator">+</span> b <span class="token operator">*</span> b <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>b<span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">int</span> t <span class="token operator">=</span> n <span class="token operator">-</span> a <span class="token operator">*</span> a <span class="token operator">-</span> b <span class="token operator">*</span> b<span class="token punctuation">;</span>            <span class="token keyword">int</span> l <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> r <span class="token operator">=</span> cnt <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>            <span class="token keyword">while</span><span class="token punctuation">(</span>l <span class="token operator">&lt;</span> r<span class="token punctuation">)</span><span class="token punctuation">{</span>                <span class="token keyword">int</span> mid <span class="token operator">=</span> l <span class="token operator">+</span> r <span class="token operator">>></span> <span class="token number">1</span><span class="token punctuation">;</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>sum<span class="token punctuation">[</span>mid<span class="token punctuation">]</span><span class="token punctuation">.</span>s <span class="token operator">>=</span> t<span class="token punctuation">)</span> r <span class="token operator">=</span> mid<span class="token punctuation">;</span>                <span class="token keyword">else</span> l <span class="token operator">=</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>sum<span class="token punctuation">[</span>l<span class="token punctuation">]</span><span class="token punctuation">.</span>s <span class="token operator">==</span> t<span class="token punctuation">)</span><span class="token punctuation">{</span>                <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d %d %d %d"</span><span class="token punctuation">,</span> a<span class="token punctuation">,</span> b<span class="token punctuation">,</span> sum<span class="token punctuation">[</span>l<span class="token punctuation">]</span><span class="token punctuation">.</span>c<span class="token punctuation">,</span> sum<span class="token punctuation">[</span>l<span class="token punctuation">]</span><span class="token punctuation">.</span>d<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><pre class=" language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">//哈希（超时）</span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;cstring></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;algorithm></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;unordered_map></span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">typedef</span> pair<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">></span> pii<span class="token punctuation">;</span>unordered_map<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> pii<span class="token operator">></span> s<span class="token punctuation">;</span><span class="token keyword">int</span> n<span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    cin <span class="token operator">>></span> n<span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> c <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> c <span class="token operator">*</span> c <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>c<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> d <span class="token operator">=</span> c<span class="token punctuation">;</span> c <span class="token operator">*</span> c <span class="token operator">+</span> d <span class="token operator">*</span> d <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>d<span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">int</span> t <span class="token operator">=</span> c <span class="token operator">*</span> c <span class="token operator">+</span> d <span class="token operator">*</span> d<span class="token punctuation">;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">count</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> s<span class="token punctuation">[</span>t<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span>c<span class="token punctuation">,</span> d<span class="token punctuation">}</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> a <span class="token operator">*</span> a <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>a<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> b <span class="token operator">=</span> a<span class="token punctuation">;</span> a <span class="token operator">*</span> a <span class="token operator">+</span> b <span class="token operator">*</span> b <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>b<span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">int</span> t <span class="token operator">=</span> n <span class="token operator">-</span> a <span class="token operator">*</span> a <span class="token operator">-</span> b <span class="token operator">*</span> b<span class="token punctuation">;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">count</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d %d %d %d"</span><span class="token punctuation">,</span> a<span class="token punctuation">,</span> b<span class="token punctuation">,</span> s<span class="token punctuation">[</span>t<span class="token punctuation">]</span><span class="token punctuation">.</span>first<span class="token punctuation">,</span> s<span class="token punctuation">[</span>t<span class="token punctuation">]</span><span class="token punctuation">.</span>second<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 蓝桥杯 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>递归与递推</title>
      <link href="2021/0415-di-gui-yu-di-tui.html"/>
      <url>2021/0415-di-gui-yu-di-tui.html</url>
      
        <content type="html"><![CDATA[<h1 id="递归与递推"><a href="#递归与递推" class="headerlink" title="递归与递推"></a>递归与递推</h1><h2 id="AcWing-92-递归实现指数型枚举"><a href="#AcWing-92-递归实现指数型枚举" class="headerlink" title="AcWing 92.递归实现指数型枚举"></a>AcWing 92.递归实现指数型枚举</h2><p>从 $1∼n$ 这 $n$ 个整数中随机选取任意多个，输出所有可能的选择方案。</p><h4 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h4><p>输入一个整数 $n$。</p><h4 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h4><p>每行输出一种方案。</p><p>同一行内的数必须升序排列，相邻两个数用恰好 11 个空格隔开。</p><p>对于没有选任何数的方案，输出空行。</p><p>本题有自定义校验器（SPJ），各行（不同方案）之间的顺序任意。</p><h4 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h4><p>$1≤n≤15$</p><h4 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h4><pre class=" language-text"><code class="language-text">3</code></pre><h4 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h4><pre class=" language-text"><code class="language-text">322 311 31 21 2 3</code></pre><pre class=" language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span><span class="token string">&lt;iostream></span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">int</span> n<span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    cin <span class="token operator">>></span> n<span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> state <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> state <span class="token operator">&lt;</span> <span class="token number">1</span> <span class="token operator">&lt;&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>state<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>j<span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>state <span class="token operator">>></span> j <span class="token operator">&amp;</span> <span class="token number">1</span><span class="token punctuation">)</span> cout <span class="token operator">&lt;&lt;</span> j <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">&lt;&lt;</span> <span class="token string">" "</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        cout <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><pre class=" language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span><span class="token string">&lt;iostream></span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">int</span> n<span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">dfs</span><span class="token punctuation">(</span><span class="token keyword">int</span> depth<span class="token punctuation">,</span> <span class="token keyword">int</span> state<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>depth <span class="token operator">==</span> n<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>state <span class="token operator">>></span> i <span class="token operator">&amp;</span> <span class="token number">1</span><span class="token punctuation">)</span>                cout <span class="token operator">&lt;&lt;</span> i <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">&lt;&lt;</span> <span class="token string">" "</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        cout <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token function">dfs</span><span class="token punctuation">(</span>depth <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> state<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">dfs</span><span class="token punctuation">(</span>depth <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> state <span class="token operator">|</span> <span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">&lt;&lt;</span> depth<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>cpp<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    cin <span class="token operator">>></span> n<span class="token punctuation">;</span>    <span class="token function">dfs</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h2 id="AcWing-94-递归实现排列型枚举"><a href="#AcWing-94-递归实现排列型枚举" class="headerlink" title="AcWing 94. 递归实现排列型枚举"></a>AcWing 94. 递归实现排列型枚举</h2><p>把 $1∼n$ 这 $n$ 个整数排成一行后随机打乱顺序，输出所有可能的次序。</p><h4 id="输入格式-1"><a href="#输入格式-1" class="headerlink" title="输入格式"></a>输入格式</h4><p>一个整数 $n$。</p><h4 id="输出格式-1"><a href="#输出格式-1" class="headerlink" title="输出格式"></a>输出格式</h4><p>按照从小到大的顺序输出所有方案，每行 11 个。</p><p>首先，同一行相邻两个数用一个空格隔开。</p><p>其次，对于两个不同的行，对应下标的数一一比较，字典序较小的排在前面。</p><h4 id="数据范围-1"><a href="#数据范围-1" class="headerlink" title="数据范围"></a>数据范围</h4><p>$1≤n≤9$</p><h4 id="输入样例：-1"><a href="#输入样例：-1" class="headerlink" title="输入样例："></a>输入样例：</h4><pre class=" language-text"><code class="language-text">3</code></pre><h4 id="输出样例：-1"><a href="#输出样例：-1" class="headerlink" title="输出样例："></a>输出样例：</h4><pre class=" language-text"><code class="language-text">1 2 31 3 22 1 32 3 13 1 23 2 1</code></pre><pre class=" language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span><span class="token string">&lt;iostream></span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">int</span> n<span class="token punctuation">,</span> a<span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">bool</span> f<span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">dfs</span><span class="token punctuation">(</span><span class="token keyword">int</span> u<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>u <span class="token operator">==</span> n<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span><span class="token punctuation">{</span>            cout <span class="token operator">&lt;&lt;</span> a<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;&lt;</span> <span class="token string">" "</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        cout <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>f<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token keyword">continue</span><span class="token punctuation">;</span>        f<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        a<span class="token punctuation">[</span>u<span class="token punctuation">]</span> <span class="token operator">=</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token function">dfs</span><span class="token punctuation">(</span>u <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        f<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    cin <span class="token operator">>></span> n<span class="token punctuation">;</span>    <span class="token function">dfs</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h2 id="AcWing-95-费解的开关"><a href="#AcWing-95-费解的开关" class="headerlink" title="AcWing 95.费解的开关"></a>AcWing 95.费解的开关</h2><p>你玩过“拉灯”游戏吗？</p><p>25 盏灯排成一个 $5×5$ 的方形。</p><p>每一个灯都有一个开关，游戏者可以改变它的状态。</p><p>每一步，游戏者可以改变某一个灯的状态。</p><p>游戏者改变一个灯的状态会产生连锁反应：和这个灯上下左右相邻的灯也要相应地改变其状态。</p><p>我们用数字 1 表示一盏开着的灯，用数字 0 表示关着的灯。</p><p>下面这种状态</p><pre class=" language-text"><code class="language-text">1011101101101111000011011</code></pre><p>在改变了最左上角的灯的状态后将变成：</p><pre class=" language-text"><code class="language-text">0111111101101111000011011</code></pre><p>再改变它正中间的灯后状态将变成：</p><pre class=" language-text"><code class="language-text">0111111001110011010011011</code></pre><p>给定一些游戏的初始状态，编写程序判断游戏者是否可能在 6 步以内使所有的灯都变亮。</p><h4 id="输入格式-2"><a href="#输入格式-2" class="headerlink" title="输入格式"></a>输入格式</h4><p>第一行输入正整数 $n$，代表数据中共有 $n$ 个待解决的游戏初始状态。</p><p>以下若干行数据分为 $n$ 组，每组数据有 5 行，每行 5 个字符。</p><p>每组数据描述了一个游戏的初始状态。</p><p>各组数据间用一个空行分隔。</p><h4 id="输出格式-2"><a href="#输出格式-2" class="headerlink" title="输出格式"></a>输出格式</h4><p>一共输出 $n$ 行数据，每行有一个小于等于 6 的整数，它表示对于输入数据中对应的游戏状态最少需要几步才能使所有灯变亮。</p><p>对于某一个游戏初始状态，若 6 步以内无法使所有灯变亮，则输出 −1。</p><h4 id="数据范围-2"><a href="#数据范围-2" class="headerlink" title="数据范围"></a>数据范围</h4><p>$0&lt;n≤500$</p><h4 id="输入样例：-2"><a href="#输入样例：-2" class="headerlink" title="输入样例："></a>输入样例：</h4><pre class=" language-text"><code class="language-text">3001110101110001110101110011101111011111011111111110111111111111111111111111</code></pre><p>输出样例：</p><pre class=" language-text"><code class="language-text">32-1</code></pre><pre class=" language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span><span class="token string">&lt;iostream></span></span><span class="token macro property">#<span class="token directive keyword">include</span><span class="token string">&lt;cstring></span></span><span class="token macro property">#<span class="token directive keyword">include</span><span class="token string">&lt;algorithm></span></span><span class="token macro property">#<span class="token directive keyword">define</span> INF 0x3f3f3f3f</span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">char</span> g<span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">int</span> dx<span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">int</span> dy<span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">turn</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">,</span> <span class="token keyword">int</span> y<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">5</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">int</span> a <span class="token operator">=</span> x <span class="token operator">+</span> dx<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> b <span class="token operator">=</span> y <span class="token operator">+</span> dy<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>a <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token operator">||</span> a <span class="token operator">></span> <span class="token number">4</span> <span class="token operator">||</span> b <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token operator">||</span> b <span class="token operator">></span> <span class="token number">4</span><span class="token punctuation">)</span> <span class="token keyword">continue</span><span class="token punctuation">;</span>        g<span class="token punctuation">[</span>a<span class="token punctuation">]</span><span class="token punctuation">[</span>b<span class="token punctuation">]</span> <span class="token operator">^</span><span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">work</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> ans <span class="token operator">=</span> INF<span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> k <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> k <span class="token operator">&lt;</span> <span class="token number">1</span> <span class="token operator">&lt;&lt;</span> <span class="token number">5</span><span class="token punctuation">;</span> <span class="token operator">++</span>k<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">int</span> res <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">char</span> new1<span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token function">memcpy</span><span class="token punctuation">(</span>new1<span class="token punctuation">,</span> g<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>g<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> <span class="token number">5</span><span class="token punctuation">;</span> <span class="token operator">++</span>j<span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>k <span class="token operator">>></span> j <span class="token operator">&amp;</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                res<span class="token operator">++</span><span class="token punctuation">;</span>                <span class="token function">turn</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> j<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">4</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> <span class="token number">5</span><span class="token punctuation">;</span> <span class="token operator">++</span>j<span class="token punctuation">)</span><span class="token punctuation">{</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>g<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token string">'0'</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                    res<span class="token operator">++</span><span class="token punctuation">;</span>                    <span class="token function">turn</span><span class="token punctuation">(</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> j<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">int</span> flag <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">5</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>g<span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token string">'0'</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                flag <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>                <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>flag<span class="token punctuation">)</span> ans <span class="token operator">=</span> <span class="token function">min</span><span class="token punctuation">(</span>ans<span class="token punctuation">,</span> res<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">memcpy</span><span class="token punctuation">(</span>g<span class="token punctuation">,</span> new1<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>g<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>ans <span class="token operator">></span> <span class="token number">6</span><span class="token punctuation">)</span> ans <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> ans<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> t<span class="token punctuation">;</span>    cin <span class="token operator">>></span> t<span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>t<span class="token operator">--</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">5</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> cin <span class="token operator">>></span> g<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>        cout <span class="token operator">&lt;&lt;</span> <span class="token function">work</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><pre class=" language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span><span class="token string">&lt;iostream></span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">int</span> n<span class="token punctuation">,</span> m<span class="token punctuation">,</span> a<span class="token punctuation">[</span><span class="token number">30</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">bool</span> f<span class="token punctuation">[</span><span class="token number">30</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">dfs</span><span class="token punctuation">(</span><span class="token keyword">int</span> u<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>u <span class="token operator">==</span> m<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> m<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span><span class="token punctuation">{</span>            cout <span class="token operator">&lt;&lt;</span> a<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;&lt;</span> <span class="token string">" "</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        cout <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>f<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>a<span class="token punctuation">[</span>u<span class="token punctuation">]</span> <span class="token operator">></span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">continue</span><span class="token punctuation">;</span>            f<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>            a<span class="token punctuation">[</span>u <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>            <span class="token function">dfs</span><span class="token punctuation">(</span>u <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            f<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>         <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    cin <span class="token operator">>></span> n <span class="token operator">>></span> m<span class="token punctuation">;</span>    <span class="token function">dfs</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h2 id="AcWing-1209-带分数"><a href="#AcWing-1209-带分数" class="headerlink" title="AcWing 1209. 带分数"></a>AcWing 1209. 带分数</h2><p>$100$ 可以表示为带分数的形式：$100=3+\frac{69258}{714}$</p><p>还可以表示为：$100=82+\frac{3546}{197}$</p><p>注意特征：带分数中，数字 $1∼9$ 分别出现且只出现一次（不包含 $0$）。</p><p>类似这样的带分数，$100$ 有 $11$ 种表示法。</p><h4 id="输入格式-3"><a href="#输入格式-3" class="headerlink" title="输入格式"></a>输入格式</h4><p>一个正整数。</p><h4 id="输出格式-3"><a href="#输出格式-3" class="headerlink" title="输出格式"></a>输出格式</h4><p>输出输入数字用数码 $1∼9$ 不重复不遗漏地组成带分数表示的全部种数。</p><h4 id="数据范围-3"><a href="#数据范围-3" class="headerlink" title="数据范围"></a>数据范围</h4><p>$1≤N&lt;10^6$</p><h4 id="输入样例1："><a href="#输入样例1：" class="headerlink" title="输入样例1："></a>输入样例1：</h4><pre class=" language-text"><code class="language-text">100</code></pre><h4 id="输出样例1："><a href="#输出样例1：" class="headerlink" title="输出样例1："></a>输出样例1：</h4><pre class=" language-text"><code class="language-text">11</code></pre><h4 id="输入样例2："><a href="#输入样例2：" class="headerlink" title="输入样例2："></a>输入样例2：</h4><pre class=" language-text"><code class="language-text">105</code></pre><h4 id="输出样例2："><a href="#输出样例2：" class="headerlink" title="输出样例2："></a>输出样例2：</h4><pre class=" language-text"><code class="language-text">6</code></pre><pre class=" language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span><span class="token string">&lt;cstdio></span></span><span class="token macro property">#<span class="token directive keyword">include</span><span class="token string">&lt;iostream></span></span><span class="token macro property">#<span class="token directive keyword">include</span><span class="token string">&lt;cstring></span></span><span class="token macro property">#<span class="token directive keyword">include</span><span class="token string">&lt;algorithm></span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">int</span> a<span class="token punctuation">[</span><span class="token number">15</span><span class="token punctuation">]</span><span class="token punctuation">,</span> cnt <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> sum<span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">num</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> n<span class="token punctuation">,</span> p<span class="token punctuation">,</span> q<span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> <span class="token number">7</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span><span class="token punctuation">{</span>        n <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>         <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> i<span class="token punctuation">;</span> <span class="token operator">++</span>j<span class="token punctuation">)</span>            n <span class="token operator">=</span> n <span class="token operator">*</span> <span class="token number">10</span> <span class="token operator">+</span> a<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;=</span> <span class="token number">8</span> <span class="token operator">-</span> i<span class="token punctuation">;</span> <span class="token operator">++</span>j<span class="token punctuation">)</span><span class="token punctuation">{</span>            p <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> k <span class="token operator">=</span> i<span class="token punctuation">;</span> k <span class="token operator">&lt;</span> i <span class="token operator">+</span> j<span class="token punctuation">;</span> <span class="token operator">++</span>k<span class="token punctuation">)</span>                p <span class="token operator">=</span> p <span class="token operator">*</span> <span class="token number">10</span> <span class="token operator">+</span> a<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">;</span>            q <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> m <span class="token operator">=</span> i <span class="token operator">+</span> j<span class="token punctuation">;</span> m <span class="token operator">&lt;</span> <span class="token number">9</span><span class="token punctuation">;</span> <span class="token operator">++</span>m<span class="token punctuation">)</span>                q <span class="token operator">=</span> q <span class="token operator">*</span> <span class="token number">10</span> <span class="token operator">+</span> a<span class="token punctuation">[</span>m<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>sum <span class="token operator">==</span> n <span class="token operator">+</span> p <span class="token operator">/</span> q <span class="token operator">&amp;&amp;</span> p <span class="token operator">%</span> q <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>                cnt<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    cin <span class="token operator">>></span> sum<span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">9</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>            a<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">do</span><span class="token punctuation">{</span>        <span class="token function">num</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token function">next_permutation</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> a <span class="token operator">+</span> <span class="token number">9</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    cout <span class="token operator">&lt;&lt;</span> cnt<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h2 id="AcWing-116-飞行员兄弟"><a href="#AcWing-116-飞行员兄弟" class="headerlink" title="AcWing 116.飞行员兄弟"></a>AcWing 116.飞行员兄弟</h2><p>“飞行员兄弟”这个游戏，需要玩家顺利的打开一个拥有 $16$ 个把手的冰箱。</p><p>已知每个把手可以处于以下两种状态之一：打开或关闭。</p><p>只有当所有把手都打开时，冰箱才会打开。</p><p>把手可以表示为一个 $4×4$ 的矩阵，您可以改变任何一个位置 $[i,j][i,j]$ 上把手的状态。</p><p>但是，这也会使得第 $i$ 行和第 $j$ 列上的所有把手的状态也随着改变。</p><p>请你求出打开冰箱所需的切换把手的次数最小值是多少。</p><h4 id="输入格式-4"><a href="#输入格式-4" class="headerlink" title="输入格式"></a>输入格式</h4><p>输入一共包含四行，每行包含四个把手的初始状态。</p><p>符号 <code>+</code> 表示把手处于闭合状态，而符号 <code>-</code> 表示把手处于打开状态。</p><p>至少一个手柄的初始状态是关闭的。</p><h4 id="输出格式-4"><a href="#输出格式-4" class="headerlink" title="输出格式"></a>输出格式</h4><p>第一行输出一个整数 $N$，表示所需的最小切换把手次数。</p><p>接下来 $N$ 行描述切换顺序，每行输出两个整数，代表被切换状态的把手的行号和列号，数字之间用空格隔开。</p><p><strong>注意</strong>：如果存在多种打开冰箱的方式，则按照优先级整体从上到下，同行从左到右打开。</p><h4 id="数据范围-4"><a href="#数据范围-4" class="headerlink" title="数据范围"></a>数据范围</h4><p>$1≤i,j≤4$</p><h4 id="输入样例：-3"><a href="#输入样例：-3" class="headerlink" title="输入样例："></a>输入样例：</h4><pre class=" language-text"><code class="language-text">-+-----------+--</code></pre><h4 id="输出样例：-2"><a href="#输出样例：-2" class="headerlink" title="输出样例："></a>输出样例：</h4><pre class=" language-text"><code class="language-text">61 11 31 44 14 34 4</code></pre><pre class=" language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span><span class="token string">&lt;iostream></span></span><span class="token macro property">#<span class="token directive keyword">include</span><span class="token string">&lt;vector></span></span><span class="token macro property">#<span class="token directive keyword">include</span><span class="token string">&lt;algorithm></span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">typedef</span> pair<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">></span> pii<span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">,</span> <span class="token keyword">int</span> y<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">return</span> x <span class="token operator">*</span> <span class="token number">4</span> <span class="token operator">+</span> y<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> g<span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> state <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">4</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span><span class="token punctuation">{</span>        string s<span class="token punctuation">;</span>        cin <span class="token operator">>></span> s<span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> <span class="token number">4</span><span class="token punctuation">;</span> <span class="token operator">++</span>j<span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>s<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token string">'+'</span><span class="token punctuation">)</span>                state <span class="token operator">+</span><span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">&lt;&lt;</span> <span class="token function">get</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> j<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">4</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> <span class="token number">4</span><span class="token punctuation">;</span> <span class="token operator">++</span>j<span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> k <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> k <span class="token operator">&lt;</span> <span class="token number">4</span><span class="token punctuation">;</span> <span class="token operator">++</span>k<span class="token punctuation">)</span><span class="token punctuation">{</span>                g<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">+</span><span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">&lt;&lt;</span> <span class="token function">get</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> k<span class="token punctuation">)</span><span class="token punctuation">;</span>                g<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">+</span><span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">&lt;&lt;</span> <span class="token function">get</span><span class="token punctuation">(</span>k<span class="token punctuation">,</span> j<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            g<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">-</span><span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">&lt;&lt;</span> <span class="token function">get</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> j<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    vector<span class="token operator">&lt;</span>pii<span class="token operator">></span> res<span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> k <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> k <span class="token operator">&lt;</span> <span class="token number">1</span> <span class="token operator">&lt;&lt;</span> <span class="token number">16</span><span class="token punctuation">;</span> <span class="token operator">++</span>k<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token comment" spellcheck="true">//枚举操作k</span>        <span class="token keyword">int</span> now <span class="token operator">=</span> state<span class="token punctuation">;</span>        vector<span class="token operator">&lt;</span>pii<span class="token operator">></span> path<span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">16</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>k <span class="token operator">>></span> i <span class="token operator">&amp;</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                <span class="token keyword">int</span> x <span class="token operator">=</span> i <span class="token operator">/</span> <span class="token number">4</span><span class="token punctuation">,</span> y <span class="token operator">=</span> i <span class="token operator">%</span> <span class="token number">4</span><span class="token punctuation">;</span>                now <span class="token operator">^</span><span class="token operator">=</span> g<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">[</span>y<span class="token punctuation">]</span><span class="token punctuation">;</span>                path<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span><span class="token punctuation">{</span>x<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> y<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>now <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>res<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">||</span> res<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">></span> path<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> res <span class="token operator">=</span> path<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    cout <span class="token operator">&lt;&lt;</span> res<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">auto</span> p <span class="token operator">:</span> res<span class="token punctuation">)</span> cout <span class="token operator">&lt;&lt;</span> p<span class="token punctuation">.</span>first <span class="token operator">&lt;&lt;</span> <span class="token string">" "</span> <span class="token operator">&lt;&lt;</span> p<span class="token punctuation">.</span>second <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 蓝桥杯 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java-inheritance</title>
      <link href="2021/0409java-inheritance.html"/>
      <url>2021/0409java-inheritance.html</url>
      
        <content type="html"><![CDATA[<h1 id="Java-继承-inheritance"><a href="#Java-继承-inheritance" class="headerlink" title="Java-继承(inheritance)"></a>Java-继承(inheritance)</h1><p><strong>设计面向对象语言的初衷</strong></p><ul><li>可维护</li><li>可扩展</li><li>代码复用</li><li>低耦合</li></ul><h2 id="理解继承"><a href="#理解继承" class="headerlink" title="理解继承"></a>理解继承</h2><h3 id="细说继承"><a href="#细说继承" class="headerlink" title="细说继承"></a>细说继承</h3><ul><li>继承是使用已存在的类的定义作为基础，建立新类的技术</li><li>继承是在保留原有类的数据成员和成员函数的基础上，派生出新类，<strong>新的类可以有某种程度的变异</strong></li><li>通过继承，新类<strong>自动具有了原有类的所有数据成员和成员函数</strong>，因而只需定义原有类型没有的新的数据成员和成员函数。实现了<strong>软件复用</strong>，使得类之间具备了<strong>层次性</strong></li><li>通过继承和派生形成的类族，反映了面向对象问题域、主题等概念。</li></ul><h3 id="类的继承（is-a）"><a href="#类的继承（is-a）" class="headerlink" title="类的继承（is a）"></a>类的继承（is a）</h3><ol><li><p>被继承的类称为父类（superclass）,继承后产生的类称为子类（subclass）。 </p></li><li><p>单继承：如果子类只能有一个直接父类，称为单继承。 </p></li></ol><ul><li>例如，轮船、客轮；人、大人 。 </li></ul><ol start="3"><li>多继承：如果子类可以有多个直接父类，称为多继承。 </li></ol><ul><li><p>例如，客轮是轮船和客运工具的子类 </p></li><li><p>例如，沙发床是沙发和床的子类</p></li></ul><h3 id="基类和派生类的关系"><a href="#基类和派生类的关系" class="headerlink" title="基类和派生类的关系"></a>基类和派生类的关系</h3><ul><li><p>基类是对若干个派生类的抽象 </p><ul><li>基类抽取了派生类的公共特征，在设计类时，<strong>应该将通用的方法放到超类中</strong></li></ul></li><li><p>派生类是基类的具体化</p><ul><li>通过扩展超类定义子类的时候，仅需指出子类与超类的不同之处，通过增加数据成员或成员函数将基类变为某种更有用的类型</li></ul></li><li><p>派生类可以看作基类定义的延续（抽象类在多态中细说）</p><ul><li>先定义一个抽象基类，该基类中有些操作并未实现</li><li>然后定义非抽象的派生类，实现抽象基类中未实现的操作</li></ul></li></ul><h4 id="子类从父类那里继承了什么？"><a href="#子类从父类那里继承了什么？" class="headerlink" title="子类从父类那里继承了什么？"></a>子类从父类那里继承了什么？</h4><ol><li><p>子类拥有父类的所有属性和方法，<strong>只不过父类的私有属性和方法，子类是无法直接访问到的</strong>。</p></li><li><p>子类可以拥有自己属性和方法，即子类可以对父类进行扩展。</p></li><li><p>子类可以用自己的方式实现父类的方法。（<strong>方法覆盖</strong>）</p></li></ol><h4 id="子类从父类那里不能继承什么？"><a href="#子类从父类那里不能继承什么？" class="headerlink" title="子类从父类那里不能继承什么？"></a>子类从父类那里不能继承什么？</h4><ul><li><strong>子类不能继承父类的构造方法</strong>    <ul><li>如何解决？</li></ul></li></ul><h3 id="继承的进一步理解"><a href="#继承的进一步理解" class="headerlink" title="继承的进一步理解"></a>继承的进一步理解</h3><ul><li><p>继承避免了公用代码的重复开发，减少代码的冗余，提高程序的复用性；</p></li><li><p><strong>支持多态（通过向上映射）</strong>，提高程序的可扩展性；</p></li><li><p>继承是类实现可重用性和可扩充性的关键持征。在继承关系下类之间组成网状的层次结构。</p></li><li><p>通过继承增强一致性，从而减少模块间的接口和界面。</p></li></ul><h2 id="Java继承"><a href="#Java继承" class="headerlink" title="Java继承"></a>Java继承</h2><ul><li><p><strong>Java不支持类的多继承</strong>，但支持接口的多继承。</p></li><li><p>Java中的继承通过关键字<strong>extends</strong>实现。</p></li><li><p>类继承的格式：</p><pre class=" language-java"><code class="language-java"><span class="token punctuation">[</span>修饰符<span class="token punctuation">]</span><span class="token keyword">class</span> 类名 <span class="token keyword">extends</span> 父类名<span class="token punctuation">{</span>    类体；<span class="token punctuation">}</span></code></pre></li></ul><h4 id="子类构造函数"><a href="#子类构造函数" class="headerlink" title="子类构造函数"></a>子类构造函数</h4><ul><li>构造函数不能被继承；</li><li>无参子类构造函数的编写<ul><li>子类可以通过<strong>super()<strong>显示调用父类无参的构造函数，</strong>也可以隐式调用</strong></li></ul></li><li>有参子类构造函数的编写<ul><li>初始化父类的成员变量；</li><li>初始化子类的成员变量</li><li>必须显示调用父类有参构造函数</li></ul></li><li>无论使用this调用本类构造函数，还是使用super调用父类构造函数，都必须是<strong>该方法体中的第一条可以执行语句</strong>，否则会产生语法错误。</li></ul><h4 id="子类对象的生成-构造函数的调用顺序"><a href="#子类对象的生成-构造函数的调用顺序" class="headerlink" title="子类对象的生成(构造函数的调用顺序)"></a>子类对象的生成(构造函数的调用顺序)</h4><ul><li>创建子类对象时，子类总是按<strong>层次结构从上到下</strong>的顺序调用所有超类的构造函数。如果继承和组合联用，要先构造基类的构造函数，然后调用组合对象的构造函数（组合按照声明的顺序调用）。</li><li>如果父类没有不带参数的构造方法，则在子类的构造方法中必须明确的告诉调用父类的某个带参数的构造方法，通过<strong>super关键字</strong>，这条语句还必须出现在构造方法的第一句。</li></ul><hr><ul><li><p>子类创建对象时，<strong>子类的构造方法</strong>总是先调用父类的某个构造方法，完成父类部分的创建；然后再调用子类自己的构造方法，完成子类部分的创建。</p></li><li><p>如果子类的构造方法没有明显地指明使用父类的哪个构造方法，子类就调用父类的不带参数的构造方法 。</p></li><li><p>子类在创建一个子类对象时，不仅子类中声明的成员变量被分配了内存，而且父类的所有的成员变量也都分配了内存空间，但子类只能操作继承的那部分成员变量 。</p></li><li><p>子类可以通过继承的方法来操作子类未继承的变量和方法 。</p></li></ul><h4 id="super关键字"><a href="#super关键字" class="headerlink" title="super关键字"></a>super关键字</h4><ol><li><p>如果子类调用父类的构造函数，则通过 <strong>super()</strong> 调用来实现。</p></li><li><p>如果子类调用父类的同名方法，则通过 **super.方法名() **来实现。</p></li></ol><h4 id="this关键字"><a href="#this关键字" class="headerlink" title="this关键字"></a>this关键字</h4><ol><li>this变量代表对象本身。</li><li>当类中有两个同名变量，一个属于类的成员变量，而另一个属于某个特定的方法（方法中的局部变量），使用this区分成员变量和局部变量。</li><li>使用this简化构造函数的调用。</li></ol><h4 id="this引用与super引用的对比"><a href="#this引用与super引用的对比" class="headerlink" title="this引用与super引用的对比"></a>this引用与super引用的对比</h4><p>Java 每个类都默认地具有 null、this、 super三个域，所以在任何类中都可以不加说明就可以直接引用它们：</p><ol><li>null ：代表“空”，用在定义一个对象但尚未为其开辟内存空间时。</li><li>this 和 super ：是常用的指代子类对象和父类对象的关键字</li></ol><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p><strong>this用于：</strong></p><ol><li>引用自身对象的成员变量<ul><li>this.age;</li></ul></li><li>引用自身对象的成员方法<ul><li>this.diaplay();</li></ul></li><li>调用自身的构造方法<ul><li>this(“Jack”,Male,10);</li></ul></li></ol><p><strong>super用于：</strong></p><ol><li>引用父类对象的成员变量<ul><li>super.age;</li></ul></li><li>引用父类对象的成员方法<ul><li>super.diaplay();</li></ul></li><li>调用父类的构造方法<ul><li>super(“Jack”,Male,10);</li></ul></li></ol><p><strong>Note：</strong></p><ol><li>无论使用this调用本类构造函数，还是使用super调用父类构造函数，都必须是该方法体中的第一条可以执行语句。</li><li>否则会产生语法错误。</li></ol><p><a href="https://imgtu.com/i/cUBwTO"><img src="https://z3.ax1x.com/2021/04/09/cUBwTO.png" alt="复习访问修饰符"></a></p><h4 id="派生类-子类成员（变量和方法）"><a href="#派生类-子类成员（变量和方法）" class="headerlink" title="派生类/子类成员（变量和方法）"></a>派生类/子类成员（变量和方法）</h4><ul><li>保护成员可以被派生类直接访问（protected）</li><li>公共成员可以被派生类直接访问（public）</li><li>如果子类和父类位于同一个包中，子类可以直接访问父类的不加权限修饰符的成员（default）</li><li>派生类可以重新定义基类的成员函数（覆盖）</li><li>派生类可以添加自己的新成员（变量和方法）</li></ul><h4 id="保持基类数据成员私有性"><a href="#保持基类数据成员私有性" class="headerlink" title="保持基类数据成员私有性"></a>保持基类数据成员私有性</h4><p>将基类数据成员定义成private</p><ul><li>派生类中通过相应的访问函数进行访问</li><li>优点：保持基类的封装性</li><li>缺点：降低了访问效率</li></ul><h4 id="关于保护成员的使用"><a href="#关于保护成员的使用" class="headerlink" title="关于保护成员的使用"></a>关于保护成员的使用</h4><ul><li>保护成员会破坏基类的封装性<ul><li>派生类可以直接访问和修改</li></ul></li><li>关于保护成员的使用<ul><li>如果基类仅向其派生类提供服务，而不对其他客户提供该服务，使用protected成员访问说明符是合适的</li><li>例如Owner和Son、Wife、Daughter是父子关系，Owner的车和房产可以被子类直接访问，但是不对其他类开放，那么车和房产可以声明为protected的权限。</li></ul></li></ul><h4 id="向上转型-upcasting"><a href="#向上转型-upcasting" class="headerlink" title="向上转型(upcasting)"></a>向上转型(upcasting)</h4><ul><li>将子类转换成父类，在继承关系上面是向上移动的，所以一般称之为向上转型或者向上映射。</li><li>由于向上转型是从一个叫专用类型向较通用类型转换，所以它总是安全的，唯一发生变化的可能就是<strong>属性和方法的丢失</strong>。</li><li>这就是为什么编译器在“未曾明确表示转型”或者“未曾指定特殊标记”的情况下，仍然允许向上转型的原因。</li></ul><p><a href="https://imgtu.com/i/cUBBkD"><img src="https://z3.ax1x.com/2021/04/09/cUBBkD.png" alt="示例代码"></a></p><p><strong>缺憾：</strong> 只能调用父类中定义的属性和方法，对于子类中的方法和属性它就望尘莫及了，必须<strong>强制转成子类类型</strong></p><h4 id="变量隐藏（变量全隐藏）"><a href="#变量隐藏（变量全隐藏）" class="headerlink" title="变量隐藏（变量全隐藏）"></a>变量隐藏（变量全隐藏）</h4><ol><li><p>变量隐藏：在子类对父类的继承中，如果子类的成员变量和父类的成员变量同名，此时称为子类隐藏（override）了父类的成员变量。</p></li><li><p>子类若要引用父类的同名变量。要用 super 关键字做前缀加圆点操作符引用, 即<strong>super.变量名</strong></p></li></ol><h4 id="方法覆盖"><a href="#方法覆盖" class="headerlink" title="方法覆盖"></a>方法覆盖</h4><ol><li>方法覆盖：在子类中重写父类的方法，它们的<strong>名称、参数以及返回类型完全相同</strong>。</li><li>通过改写方法体来完成不同的功能</li></ol><h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><h3 id="继承是否破坏了类的封装性？"><a href="#继承是否破坏了类的封装性？" class="headerlink" title="继承是否破坏了类的封装性？"></a>继承是否破坏了类的封装性？</h3><ul><li>是的。继承破坏了封装性，换句话说，子类依赖于父类的实现细节。**继承很容易改变父类实现的细节(所以父类中能写成final尽量写成final)**，即使父类整体没有问题，也有可能因为子类细节实现不当，而破坏父类的约束。</li><li>其实这是一个平衡关系，不是绝对关系，一定程度的封装和一定程度的继承，可以提高开发效率，继承破坏了封装， 但是有时继承是必须的，为了继承牺牲一定的封装是允许的。不能绝对的为了封装，就不去继承。</li></ul><h3 id="谨慎继承"><a href="#谨慎继承" class="headerlink" title="谨慎继承"></a>谨慎继承</h3><ul><li>继承是一种强耦合关系。父类变，子类就必须变。</li><li>继承破坏了封装，子类可以重写父类的方法，子类可以直接访问保护成员。</li><li>那么到底要不要使用继承呢？<ul><li>《Think in java》中提供了解决办法：问一问自己是否需要从子类向父类进行向上转型。如果<strong>必须向上转型</strong>，则继承是必要的，但是如果不需要，则应当好好考虑自己是否需要继承。</li></ul></li></ul><h3 id="继承的使用原则"><a href="#继承的使用原则" class="headerlink" title="继承的使用原则"></a>继承的使用原则</h3><ul><li>合理使用继承，谨慎继承，<strong>继承树的层次不可太多</strong></li><li>继承是一种提高程序代码的可重用性、以及提高系统的可扩展性的有效手段</li><li>但是，如果继承树非常复杂、或者随便扩展本来不是专门为继承而设计的类，反而会削弱系统的可扩展性和可维护性</li></ul>]]></content>
      
      
      <categories>
          
          <category> Notes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SQL作业</title>
      <link href="2021/0408sql-zuo-ye.html"/>
      <url>2021/0408sql-zuo-ye.html</url>
      
        <content type="html"><![CDATA[<h1 id="SQL作业"><a href="#SQL作业" class="headerlink" title="SQL作业"></a>SQL作业</h1><blockquote><p>再多练练</p></blockquote><p>SELECT 字段1, 字段2, … (或者 *) （选择哪些数据列）</p><p>FROM 表名[, 表名…] （从哪些表里选择）</p><p>[JOIN 表名 ON 相等条件表达式] （这些表怎么连接）</p><p>[WHERE 条件表达式] （得到的数据怎么筛选）</p><p>[GROUP BY 字段] （需不需要对结果集进行分组）</p><p>[HAVING 条件表达式] （筛选分组后通过聚合函数得到的值）</p><p>[ORDER BY 字段]; （指定排序方式）</p><p><strong>现有关系模式如下：</strong> </p><p>学生（学号，姓名，性别，年龄）；</p><p>Student (sid, sname, sex, age);</p><p>课程（课程号，课程名，教师姓名）；</p><p>course (cid, cname, tname)；</p><p>选课表（课程号，学号，成绩）</p><p>SC (cid, sid, score, date)；</p><pre class=" language-sql"><code class="language-sql"><span class="token comment" spellcheck="true">--1.检索年龄大于20岁的男生的学号和姓名。</span><span class="token keyword">select</span> sid<span class="token punctuation">,</span> sname <span class="token keyword">from</span> Student <span class="token keyword">where</span> sex <span class="token operator">=</span> <span class="token string">'男'</span> <span class="token operator">and</span> age <span class="token operator">></span> <span class="token number">20</span><span class="token comment" spellcheck="true">--2.检索选修了姓刘的老师所教授的课程的女学生的姓名。</span><span class="token keyword">select</span> sname<span class="token keyword">from</span> Student<span class="token punctuation">,</span> Course<span class="token punctuation">,</span> SC<span class="token keyword">where</span> Student<span class="token punctuation">.</span>sid <span class="token operator">=</span> SC<span class="token punctuation">.</span>sid <span class="token operator">and</span> Course<span class="token punctuation">.</span>cid <span class="token operator">=</span> SC<span class="token punctuation">.</span>cid <span class="token operator">and</span> sex <span class="token operator">=</span> <span class="token string">'女'</span> <span class="token operator">and</span> tname <span class="token operator">like</span> <span class="token string">'刘%'</span><span class="token comment" spellcheck="true">--3.检索李想同学不学的课程的课程号和课程名。</span><span class="token keyword">select</span> Course<span class="token punctuation">.</span>cid<span class="token punctuation">,</span> cname<span class="token keyword">from</span> Course<span class="token punctuation">,</span> SC<span class="token keyword">where</span> Course<span class="token punctuation">.</span>cid <span class="token operator">=</span> SC<span class="token punctuation">.</span>cid<span class="token operator">and</span> Course<span class="token punctuation">.</span>cid <span class="token operator">not</span> <span class="token operator">in</span><span class="token punctuation">(</span><span class="token keyword">select</span> cid                        <span class="token keyword">from</span> Student<span class="token punctuation">,</span> SC                       <span class="token keyword">where</span> Student<span class="token punctuation">.</span>sid <span class="token operator">=</span> SC<span class="token punctuation">.</span>sid <span class="token operator">and</span> sname <span class="token operator">=</span> <span class="token string">'李想'</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">--4.检索至少选修了两门课程的学生的学号。</span><span class="token keyword">select</span> <span class="token keyword">distinct</span> s1<span class="token punctuation">.</span>sid <span class="token keyword">from</span> SC s1<span class="token punctuation">,</span> SC s2<span class="token keyword">where</span> s1<span class="token punctuation">.</span>sid <span class="token operator">=</span> s2<span class="token punctuation">.</span>sid <span class="token operator">and</span> s1<span class="token punctuation">.</span>cid <span class="token operator">&lt;></span> s2<span class="token punctuation">.</span>cid<span class="token comment" spellcheck="true">--5.求刘老师所教授课程的每门课的平均成绩。</span><span class="token keyword">select</span> SC<span class="token punctuation">.</span>cid<span class="token punctuation">,</span> <span class="token function">avg</span><span class="token punctuation">(</span>score<span class="token punctuation">)</span> <span class="token keyword">as</span> avg_score<span class="token keyword">from</span> SC <span class="token keyword">join</span> Course <span class="token keyword">on</span> SC<span class="token punctuation">.</span>cid <span class="token operator">=</span> Course<span class="token punctuation">.</span>cid <span class="token keyword">where</span> tname <span class="token operator">like</span> <span class="token string">'刘%'</span><span class="token keyword">group</span> <span class="token keyword">by</span> SC<span class="token punctuation">.</span>cid<span class="token comment" spellcheck="true">--6.假设不存在重修的情况，请统计每门课的选修人数(选课人数超过两人的课程才统计)。</span><span class="token comment" spellcheck="true">--要求显示课程号和人数，查询结果按人数降序排列，若人数相同，按课程号升序排列。</span><span class="token keyword">select</span> cid<span class="token punctuation">,</span> <span class="token function">count</span><span class="token punctuation">(</span>cid<span class="token punctuation">)</span> <span class="token keyword">as</span> stu_total<span class="token keyword">from</span> SC<span class="token keyword">group</span> <span class="token keyword">by</span> cid<span class="token keyword">having</span> <span class="token function">count</span><span class="token punctuation">(</span>cid<span class="token punctuation">)</span> <span class="token operator">>=</span> <span class="token number">2</span><span class="token keyword">order</span> <span class="token keyword">by</span> <span class="token function">count</span><span class="token punctuation">(</span>cid<span class="token punctuation">)</span> <span class="token keyword">desc</span><span class="token punctuation">,</span> cid<span class="token comment" spellcheck="true">--7.求年龄大于所有女生年龄的男生的姓名和年龄。</span><span class="token keyword">select</span> sname<span class="token punctuation">,</span> age<span class="token keyword">from</span> Student<span class="token keyword">where</span> sex <span class="token operator">=</span> <span class="token string">'男'</span> <span class="token operator">and</span> age <span class="token operator">></span> <span class="token keyword">all</span><span class="token punctuation">(</span><span class="token keyword">select</span> age                                <span class="token keyword">from</span> Student                               <span class="token keyword">where</span> sex <span class="token operator">=</span> <span class="token string">'女'</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">--8.假定不存在重修的情况，求选修了所有课程的学生的学号姓名。(可以不用相关子查询做)</span><span class="token comment" spellcheck="true">--（选出不存在没有选过的课程的学生</span><span class="token keyword">select</span> sid<span class="token punctuation">,</span> sname<span class="token keyword">from</span> Student A<span class="token keyword">where</span> <span class="token operator">not</span> <span class="token keyword">exists</span><span class="token punctuation">(</span><span class="token keyword">select</span> cid                  <span class="token keyword">from</span> Course B                 <span class="token keyword">where</span> <span class="token operator">not</span> <span class="token keyword">exists</span><span class="token punctuation">(</span><span class="token keyword">select</span> <span class="token operator">*</span>                                   <span class="token keyword">from</span> SC C                                  <span class="token keyword">where</span> A<span class="token punctuation">.</span>sid <span class="token operator">=</span> C<span class="token punctuation">.</span>sid <span class="token operator">and</span> B<span class="token punctuation">.</span>cid <span class="token operator">=</span> C<span class="token punctuation">.</span>cid<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">--9.查询重修次数在2次以上的学生学号，课程号，重修次数</span><span class="token keyword">select</span> sid<span class="token punctuation">,</span> cid<span class="token punctuation">,</span> <span class="token function">count</span><span class="token punctuation">(</span><span class="token keyword">date</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span> <span class="token keyword">as</span> retake<span class="token keyword">from</span> SC<span class="token keyword">group</span> <span class="token keyword">by</span> sid<span class="token punctuation">,</span> cid<span class="token keyword">having</span> <span class="token function">count</span><span class="token punctuation">(</span><span class="token keyword">date</span><span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">2</span><span class="token comment" spellcheck="true">--10.查询重修学生人数最多的课程号，课程名，教师姓名</span><span class="token keyword">select</span> B<span class="token punctuation">.</span>cid<span class="token punctuation">,</span> cname<span class="token punctuation">,</span> tname<span class="token keyword">from</span> Course B<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">select</span> cid<span class="token punctuation">,</span> sid                 <span class="token keyword">from</span> SC                 <span class="token keyword">group</span> <span class="token keyword">by</span> cid<span class="token punctuation">,</span> sid                 <span class="token keyword">having</span> <span class="token function">count</span><span class="token punctuation">(</span><span class="token keyword">date</span><span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">as</span> C<span class="token keyword">where</span> B<span class="token punctuation">.</span>cid <span class="token operator">=</span> C<span class="token punctuation">.</span>cid<span class="token keyword">group</span> <span class="token keyword">by</span> B<span class="token punctuation">.</span>cid<span class="token punctuation">,</span> cname<span class="token punctuation">,</span> tname<span class="token keyword">having</span> <span class="token function">count</span><span class="token punctuation">(</span>sid<span class="token punctuation">)</span> <span class="token operator">>=</span> <span class="token keyword">all</span><span class="token punctuation">(</span><span class="token keyword">select</span> <span class="token function">count</span><span class="token punctuation">(</span>sid<span class="token punctuation">)</span>                          <span class="token keyword">from</span> SC                          <span class="token keyword">group</span> <span class="token keyword">by</span> cid<span class="token punctuation">,</span> sid                          <span class="token keyword">having</span> <span class="token function">count</span><span class="token punctuation">(</span>sid<span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">1</span><span class="token punctuation">)</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> Homework </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于Java</title>
      <link href="2021/0408-guan-yu-java.html"/>
      <url>2021/0408-guan-yu-java.html</url>
      
        <content type="html"><![CDATA[<h1 id="关于Java"><a href="#关于Java" class="headerlink" title="关于Java"></a>关于Java</h1><h2 id="可变参数"><a href="#可变参数" class="headerlink" title="可变参数"></a>可变参数</h2><p>Java可变参数的底层实现，实际上就是一个数组，简单的证明方式如下：<br>定义2个方法：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> a<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> a<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span></code></pre><p>上述代码在编译阶段就提示异常。原因是可变长参数编译后会被转成<code>Int[]</code>，也就是会另一个方法定义重复了。<br>想详细了解可变参数，也可以去看下编译后的JVM指令，具体可百度查询下，这里就不做详述了。</p><p>使用可变参数时，需要注意以下3点：<br>1、如果有明确的方法可调用，会优化选择”已明确的方法“，如果没有明确的方法，才会选择可变参数对应的方法。如下代码：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">)</span> <span class="token punctuation">{</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"A"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span> <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> a<span class="token punctuation">)</span> <span class="token punctuation">{</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"B"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>执行，<code>test(1)</code>，会输出A</p><p>2、Java允许存在多个可变参数的方法，但在调用时如果有多个方法可供选择，则会出现编译时间的异常提示（ambiguous method call：不明确的方法调用）。如下代码：</p><pre class=" language-java"><code class="language-java"> <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> a<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span> <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token keyword">long</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> a<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span></code></pre><p> 在执行<code>test(1)</code>，2个方法都可以选择。则出现编译期的异常。<br> 像楼主说的，如果传的是数组为何又正常？通过上述描述，相信楼主也能明白其原因：<br> 如果执行<code>test(new int[]&#123;1&#125;)</code>,则<code>test(long... a)</code>是调用不到的（方法参数只接收<code>long[]/long/int/short/byte/char</code>），即能找可唯一选择的方法。</p><p>3、定义方法参数时，可变参数只能写在最后一个参数位置上，否则编译期会提示异常。</p><h2 id="继承：子类和父类的关系"><a href="#继承：子类和父类的关系" class="headerlink" title="继承：子类和父类的关系"></a>继承：子类和父类的关系</h2><h3 id="一、父类引用指向子类对象时"><a href="#一、父类引用指向子类对象时" class="headerlink" title="一、父类引用指向子类对象时"></a>一、父类引用指向子类对象时</h3><p>1、若子类覆盖了某方法，则父类引用调用子类重新定义的新方法</p><p>2、若子类未覆盖某方法，则父类引用调用父类本身的旧方法</p><p>3、若子类覆盖了某属性，但父类引用仍调用父类本身的旧属性</p><p>4、若子类未覆盖某属性，则父类引用调用父类本身的旧属性</p><p>5、父类引用不能访问子类新定义的方法</p><h3 id="二、子类引用指向自身对象时"><a href="#二、子类引用指向自身对象时" class="headerlink" title="二、子类引用指向自身对象时"></a>二、子类引用指向自身对象时</h3><p>1、若子类覆盖了某方法，则子类引用调用子类重新定义的新方法</p><p>2、若子类未覆盖某方法，则子类引用调用父类本身的旧方法</p><p>3、若子类覆盖了某属性，则子类引用调用子类重新定义的新属性</p><p>4、若子类未覆盖某属性，则子类引用调用父类本身的旧属性</p><p>5、子类引用可以访问子类新定义的方法</p><h3 id="三、示例代码"><a href="#三、示例代码" class="headerlink" title="三、示例代码"></a>三、示例代码</h3><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//B.java</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">B</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> b <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>    <span class="token keyword">void</span> <span class="token function">f1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"B.f1()"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">void</span> <span class="token function">f2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"B.f2()"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//C.java</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">C</span> <span class="token keyword">extends</span> <span class="token class-name">B</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">void</span> <span class="token function">f1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"C.f1()"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">void</span> <span class="token function">f3</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"C.f3()"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        B b <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">C</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 父类引用指向子类对象</span>        b<span class="token punctuation">.</span><span class="token function">f1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 子类覆盖了该方法，所以父类引用调用新方法</span>        b<span class="token punctuation">.</span><span class="token function">f2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 子类未覆盖该方法，所以父类引用调用旧方法</span>        <span class="token comment" spellcheck="true">// b.f3();此行去掉注释会报错，父类引用不能访问子类新定义方法</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>b<span class="token punctuation">.</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 子类覆盖了该属性，但父类引用仍旧访问旧属性</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>b<span class="token punctuation">.</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 子类未覆盖该属性，父类访问旧属性</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         C c <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">C</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 子类引用指向自身对象</span>        c<span class="token punctuation">.</span><span class="token function">f1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 子类覆盖了父类方法，所以调用新方法</span>        c<span class="token punctuation">.</span><span class="token function">f2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 子类未覆盖父类方法，所以调用旧方法</span>        c<span class="token punctuation">.</span><span class="token function">f3</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 子类调用自己新定义的方法</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>c<span class="token punctuation">.</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 子类覆盖了该属性，所以访问新属性</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>c<span class="token punctuation">.</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 子类未覆盖该属性，所以访问旧属性</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>输出：</p><pre class=" language-shell"><code class="language-shell">C.f1()B.f2()12 C.f1()B.f2()C.f3()32</code></pre><h2 id="构造方法与重载"><a href="#构造方法与重载" class="headerlink" title="构造方法与重载"></a>构造方法与重载</h2><p><strong>构造方法负责对象成员的初始值化工作</strong><br>1.方法名与类名相同<br>2.没有返回类型（void也不行）<br>3.构造方法是在创建实例时会被自动调用<br>4.一个类可能没有构造方法，但一定有系统隐蔽无参的构造方法，也有多个构造方法（他们之间构成重载）<br>5.定义了有参数的构造方法，就会屏蔽掉系统无参构造方法<br>6.构造方法不能被继承<br><strong>重载是名称相同、但参数不同的方法</strong><br>1.一个类中存在着两个以上同名方法<br>2.这两个方法的参数的组合必须不同（参数的数目不同或参数的类型的组合不同）<br>3.返回值不能作为两个方法是否构成重载的依据</p><h2 id="Java对象初始化"><a href="#Java对象初始化" class="headerlink" title="Java对象初始化"></a>Java对象初始化</h2><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">InitializeDemo</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">int</span> k <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> InitializeDemo t1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">InitializeDemo</span><span class="token punctuation">(</span><span class="token string">"t1"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> InitializeDemo t2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">InitializeDemo</span><span class="token punctuation">(</span><span class="token string">"t2"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"i"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">int</span> n <span class="token operator">=</span> <span class="token number">99</span><span class="token punctuation">;</span>    <span class="token keyword">static</span> <span class="token punctuation">{</span>        <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"静态块"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"j"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">{</span>        <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"构造块"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token function">InitializeDemo</span><span class="token punctuation">(</span>String str<span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token punctuation">(</span>k<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">":"</span> <span class="token operator">+</span> str <span class="token operator">+</span> <span class="token string">"   i="</span> <span class="token operator">+</span> i <span class="token operator">+</span> <span class="token string">"    n="</span> <span class="token operator">+</span> n<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token operator">++</span>i<span class="token punctuation">;</span>        <span class="token operator">++</span>n<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">print</span><span class="token punctuation">(</span>String str<span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token punctuation">(</span>k<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">":"</span> <span class="token operator">+</span> str <span class="token operator">+</span> <span class="token string">"   i="</span> <span class="token operator">+</span> i <span class="token operator">+</span> <span class="token string">"    n="</span> <span class="token operator">+</span> n<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token operator">++</span>n<span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token operator">++</span>i<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String args<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">new</span> <span class="token class-name">InitializeDemo</span><span class="token punctuation">(</span><span class="token string">"init"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p><strong>核心理念</strong>：</p><ol><li><p>静态属性和静态代码块都是在类加载的时候初始化和执行，两者的优先级别是一致的，且高于非静态成员，执行按照编码顺序。</p></li><li><p>非静态属性和匿名构造器在所有的构造方法之前执行，两者的优先级别一致，执行按照编码顺序。</p></li><li><p>以上执行完毕后执行构造方法中的代码。</p></li></ol><pre class=" language-shell"><code class="language-shell">1:j   i=0    n=02:构造块   i=1    n=13:t1   i=2    n=24:j   i=3    n=35:构造块   i=4    n=46:t2   i=5    n=57:i   i=6    n=68:静态块   i=7    n=999:j   i=8    n=10010:构造块   i=9    n=10111:init   i=10    n=102</code></pre><ol><li><p>运行main方法的时候，JVM会调用ClassLoader来加载<code>InitializeDemo</code>类，那么一起源于这次加载。</p></li><li><p>上面有四个静态属性，所以会按顺序逐一初始化这四个静态属性。</p></li><li><p><code>private static int k = 1;</code> 此时将k初始化为1。</p></li><li><p><code>private static InitializeDemo t1 = new InitializeDemo(&quot;t1&quot;);</code>创建<code>InitializeDemo</code>对象，那么按照核心理念中的顺序，先执行<code>private int j = print(&quot;j&quot;);</code>，打印出j，然后执行构造块，最后执行构造方法。</p></li><li><p><code>private static InitializeDemo t2 = new InitializeDemo(&quot;t2&quot;);</code>同步骤4。</p></li><li><p><code>private static int i = print(&quot;i&quot;);</code>打印i。</p></li><li><p><code>private static int n = 99;</code>直到这一步，n才被赋值为99，之前是从默认的0开始++的。</p></li><li><p>静态属性初始化完毕，代码走到静态块，打印出静态块，此时<code>n=99</code>。</p></li><li><p>静态属性和静态块执行完毕，然后执行main方法中的代码<code>new InitializeDemo(&quot;init&quot;);</code></p></li><li><p>main方法中创建对象，先初始化非静态属性，<code>private int j = print(&quot;j&quot;);</code>打印j，然后执行构造块，最后执行构造方法。</p></li></ol><blockquote><p>（静态属性=静态代码块）&gt; （非静态属性 = 构造块）&gt; 构造方法</p></blockquote><p><strong>总结一下核心理念</strong>：</p><ol><li>静态只在类加载的时候执行，且执行一次。</li><li>非静态只在实例化的时候执行，且每次实例化都执行。</li><li>静态在非静态之前执行。</li><li>静态属性和静态块的执行顺序取决于编码顺序，对它们一视同仁。</li><li>非静态属性和构造块的执行顺取决于编码顺序，对它们也一视同仁。</li><li>最后执行构造方法。</li></ol>]]></content>
      
      
      <categories>
          
          <category> Summary </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
